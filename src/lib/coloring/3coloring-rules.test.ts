import { describe, expect, test } from "bun:test"
import { ALL_LOCAL_SITUATIONS, AUTOGENERATED_RULES } from "./3coloring-rules"
import { COLOR_DOMAIN } from "./graph-utils"

const ALLOWED_COLORS: Set<number> = new Set(COLOR_DOMAIN)

describe("3coloring-rules", () => {
	test("exported collections are frozen", () => {
		expect(Object.isFrozen(ALL_LOCAL_SITUATIONS)).toBe(true)
		expect(Object.isFrozen(AUTOGENERATED_RULES)).toBe(true)
		expect(() => (ALL_LOCAL_SITUATIONS as unknown as Array<unknown>).push({})).toThrow()
		expect(() => (AUTOGENERATED_RULES as unknown as Array<unknown>).push({})).toThrow()
	})

	test("generated situations are unique and match regeneration", () => {
		const signatures = ALL_LOCAL_SITUATIONS.map(s => s.signature)
		expect(new Set(signatures).size).toBe(ALL_LOCAL_SITUATIONS.length)
		const signatureIds = ALL_LOCAL_SITUATIONS.map(s => s.situationId)
		expect(new Set(signatureIds).size).toBe(ALL_LOCAL_SITUATIONS.length)
	})

	test("all situations use allowed colors", () => {
		for (const { canon } of ALL_LOCAL_SITUATIONS) {
			for (const node of canon.nodes) {
				for (const color of node.colors) {
					expect(ALLOWED_COLORS.has(color)).toBe(true)
				}
			}
		}
	})

	test("situations with 2 or 3 colors use canonical sets", () => {
		for (const { canon } of ALL_LOCAL_SITUATIONS) {
			const colors = new Set<number>()
			for (const node of canon.nodes) {
				for (const color of node.colors) colors.add(color)
			}
			if (colors.size === 3) {
				expect(Array.from(colors).sort()).toEqual([1, 2, 3])
			} else if (colors.size === 2) {
				expect(Array.from(colors).sort()).toEqual([1, 2])
			}
		}
	})

	test("rule assignments cover exactly the situation colors", () => {
		ALL_LOCAL_SITUATIONS.forEach(({ canon }, idx) => {
			const colorsInRoots = new Set<number>()
			for (const node of Array.from(canon.nodes).filter(n => n.role === "root")) {
				for (const color of node.colors) colorsInRoots.add(color)
			}

			const colorsInAssignments = new Set<number>()
			for (const rule of AUTOGENERATED_RULES[idx]) {
				for (const branch of rule.branches) {
					for (const assignment of Object.values(branch.assignments)) {
						for (const color of assignment) colorsInAssignments.add(color)
					}
				}
			}

			const situationList = Array.from(colorsInRoots).sort()
			const assignedList = Array.from(colorsInAssignments).sort()
			expect(assignedList).toEqual(situationList)
		})
	})

	test("autogenerated rule ids are contiguous and unique", () => {
		const allRules = AUTOGENERATED_RULES.flat()
		const ids = allRules.map(rule => rule.ruleId)
		expect(ids.length).toBeGreaterThan(0)
		expect(new Set(ids).size).toBe(ids.length)

		const sorted = [...ids].sort((a, b) => a - b)
		const expected = Array.from({ length: sorted.length }, (_, i) => i)
		expect(sorted).toEqual(expected)
	})

	test("branch assignments are pairwise disjoint per node", () => {
		for (const rule of AUTOGENERATED_RULES.flat()) {
			const seenByNode = new Map<string, Set<number>>()
			for (const branch of rule.branches) {
				for (const [nodeId, colors] of Object.entries(branch.assignments)) {
					const seen = seenByNode.get(nodeId) ?? new Set<number>()
					for (const color of colors) {
						expect(seen.has(color)).toBe(false)
						seen.add(color)
					}
					seenByNode.set(nodeId, seen)
				}
			}
		}
	})
})
