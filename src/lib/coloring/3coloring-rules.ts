import { Graph, type Color, type GraphEdge, type GraphNode } from "./graph-utils"
import { analyzeRule, type BranchingRule } from "./rule-engine"

function character(i: number) {
	if (!Number.isInteger(i) || i < 1) throw new Error("index must be a positive integer")
	if (i > 26) throw new Error("index out of range (max 26)")
	return String.fromCharCode("a".charCodeAt(0) + (i - 1))
}

/**
 * Enumerates every color list considered when generating canonical neighborhoods.
 */
// const COLOR_LIST_OPTIONS = [
// 	[1, 2, 3],
// 	[1, 2],
// 	[1, 3],
// 	[2, 3]
// ] as const
const COLOR_LIST_OPTIONS = [
	[1, 2, 3, 4],
	[1, 2, 3],
	[1, 2, 4],
	[1, 3, 4],
	[2, 3, 4],
	[1, 2],
	[1, 3],
	[1, 4],
	[2, 3],
	[2, 4],
	[3, 4]
] as const

const COMPATIBLE_COLOR_LISTS: ReadonlyArray<ReadonlyArray<number>> = (() => {
	const table: number[][] = []
	for (const rootColors of COLOR_LIST_OPTIONS) {
		const compatibleWithRoot: number[] = []
		for (let d = 0; d < COLOR_LIST_OPTIONS.length; d++) {
			const D = COLOR_LIST_OPTIONS[d]
			if (new Set(rootColors).isDisjointFrom(new Set(D))) continue
			if (rootColors.length > D.length) continue
			compatibleWithRoot.push(d)
		}
		table.push(compatibleWithRoot)
	}
	return table
})()

/**
 * Exhaustively generates every canonical situation reachable under the eligible color lists.
 *
 * @returns Array of canonical situations representing the complete search space.
 */
export function* generateAllLocalSituations(minDegree = 3, maxDegree = 4) {
	const edges: GraphEdge[] = []
	const separators: GraphNode[] = []
	for (let i = 1; i <= maxDegree; i++) {
		const c = character(i)
		edges.push({ from: "v", to: c })
		separators.push({ id: c, role: "separator", colors: [] })
	}
	const seen = new Set<string>()
	for (let rootColors = 0; rootColors < COLOR_LIST_OPTIONS.length; rootColors++) {
		const nodes: GraphNode[] = [{ id: "v", colors: COLOR_LIST_OPTIONS[rootColors], role: "root" }]
		function* backtrack(i = 1, minJ = 0): Generator<GraphNode[]> {
			if (i > minDegree) yield nodes
			if (i > maxDegree) return
			for (const j of COMPATIBLE_COLOR_LISTS[rootColors]) {
				if (j < minJ) continue
				const D = COLOR_LIST_OPTIONS[j]
				nodes.push({ id: character(i), colors: D, role: "separator" })
				yield* backtrack(i + 1, Math.max(j, minJ))
				nodes.pop()
			}
		}
		for (const V of backtrack()) {
			const degree = V.length - 1
			for (const v of V) {
				if (v.role !== "separator") continue
				v.halfedges = degree - 1
			}
			const E = edges.slice(0, degree)
			const canon = new Graph(V, E).canon()
			if (!seen.has(canon.signature)) {
				yield { ...canon, situationId: seen.size }
				seen.add(canon.signature)
			}
		}
	}
}

/**
 * Memoized list of canonical situations produced at module load for reuse.
 */
export const ALL_LOCAL_SITUATIONS = Object.freeze(Array.from(generateAllLocalSituations()))

let autogeneratedRuleCounter = 0

/**
 * Generate all possible branching rules for a given local situation. Note that in general, canon
 * may have multiple roots, and we only want to enumerate assignments that are compatible.
 */
function autogenerateRules({
	canon,
	situationId
}: {
	canon: Graph
	situationId: number
}): BranchingRule[] {
	const roots = Array.from(canon.nodes).filter(node => node.role === "root")
	if (roots.length !== 1) return []

	const root = roots[0]
	if (root.colors.length === 0) return []

	const rules: BranchingRule[] = []

	if (root.colors.length >= 2) {
		const singletonBranches: BranchingRule["branches"] = root.colors.map(color => ({
			assignments: { [root.id]: [color] as readonly Color[] }
		}))
		rules.push({
			situationId,
			ruleId: autogeneratedRuleCounter,
			name: `Rule ${autogeneratedRuleCounter}`,
			description: `Auto-generated for situation #${situationId}`,
			before: canon,
			branches: singletonBranches
		})
		autogeneratedRuleCounter += 1
	}

	// one-rest split. Eg. 1,2,3 -> 1 | 2,3
	if (root.colors.length >= 3) {
		const neighborIds = Array.from(canon.neighbors(root.id)).toSorted((a, b) => a.localeCompare(b))
		const seenTypes = new Set<string>()
		for (const color of root.colors) {
			const typeKey = neighborIds.filter(id => canon.nodeById(id)?.colors.includes(color)).join("|")
			if (seenTypes.has(typeKey)) continue
			seenTypes.add(typeKey)
			const remaining = root.colors.filter(c => c !== color) as readonly Color[]
			const splitBranches: BranchingRule["branches"] = [
				{ assignments: { [root.id]: [color] as readonly Color[] } },
				{ assignments: { [root.id]: remaining } }
			]
			rules.push({
				situationId,
				ruleId: autogeneratedRuleCounter,
				name: `Rule ${autogeneratedRuleCounter}`,
				description: `Auto-generated for situation #${situationId}`,
				before: canon,
				branches: splitBranches
			})
			autogeneratedRuleCounter += 1
		}
	}

	// two-rest split. Eg. 1,2,3,4 -> 1,3 | 2,4
	if (root.colors.length >= 4) {
		const seenSplits = new Set<string>()
		for (let i = 0; i < root.colors.length; i++) {
			for (let j = i + 1; j < root.colors.length; j++) {
				const first = [root.colors[i], root.colors[j]] as readonly Color[]
				const second = root.colors.filter((_, idx) => idx !== i && idx !== j) as readonly Color[]
				const aKey = [...first].toSorted().join(",")
				const bKey = [...second].toSorted().join(",")
				const splitKey = aKey <= bKey ? `${aKey}|${bKey}` : `${bKey}|${aKey}`
				if (seenSplits.has(splitKey)) continue
				seenSplits.add(splitKey)
				const splitBranches: BranchingRule["branches"] = [
					{ assignments: { [root.id]: first } },
					{ assignments: { [root.id]: second } }
				]
				rules.push({
					situationId,
					ruleId: autogeneratedRuleCounter,
					name: `Rule ${autogeneratedRuleCounter}`,
					description: `Auto-generated for situation #${situationId}`,
					before: canon,
					branches: splitBranches
				})
				autogeneratedRuleCounter += 1
			}
		}
	}
	return rules
}

export const AUTOGENERATED_RULES = Object.freeze(
	ALL_LOCAL_SITUATIONS.map(autogenerateRules).map(rules => rules.map(analyzeRule))
)
