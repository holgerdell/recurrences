import { Graph, type Color, type GraphEdge, type GraphNode } from "./graph-utils"
import type { BranchingRule } from "./rule-engine"

function character(i: number) {
	if (!Number.isInteger(i) || i < 1) throw new Error("index must be a positive integer")
	if (i > 26) throw new Error("index out of range (max 26)")
	return String.fromCharCode("a".charCodeAt(0) + (i - 1))
}

/**
 * Require that the color list of the root vertex is less than or equal in size to the sizes of the
 * neighbors. (That is, we prioritize branching on list-size 2 vertices)
 */
const REQUIRE_ROOT_LIST_LEQ_NEIGHBOR_LIST = true

/**
 * Require that, if the root has a list of size two, then there is at most one neighbor with the
 * identical list (otherwise the two duplicates could be identified for free).
 */
const REQUIRE_NO_TWO_SAME_AS_ROOT_LIST = true

/**
 * Enumerates every color list considered when generating canonical neighborhoods.
 */
const ROOT_COLOR_LIST_OPTIONS = [
	[1, 2, 3, 4],
	[1, 2, 3],
	[1, 2]
] as const
const COLOR_LIST_OPTIONS = [
	[1, 2, 3, 4],
	[1, 2, 3],
	[1, 2, 4],
	[1, 3, 4],
	[2, 3, 4],
	[1, 2],
	[1, 3],
	[1, 4],
	[2, 3],
	[2, 4],
	[3, 4]
] as const

const COMPATIBLE_COLOR_LISTS: ReadonlyArray<ReadonlyArray<number>> = (() => {
	const table: number[][] = []
	for (const rootColors of ROOT_COLOR_LIST_OPTIONS) {
		const compatibleWithRoot: number[] = []
		for (let d = 0; d < COLOR_LIST_OPTIONS.length; d++) {
			const D = COLOR_LIST_OPTIONS[d]
			if (new Set(rootColors).isDisjointFrom(new Set(D))) continue
			if (REQUIRE_ROOT_LIST_LEQ_NEIGHBOR_LIST && rootColors.length > D.length) continue
			compatibleWithRoot.push(d)
		}
		table.push(compatibleWithRoot)
	}
	return table
})()

/**
 * Exhaustively generates every canonical situation reachable under the eligible color lists.
 *
 * @returns Array of canonical situations representing the complete search space.
 */
export function* generateAllLocalSituations(minDegree = 3, maxDegree = 4) {
	const edges: GraphEdge[] = []
	for (let i = 1; i <= maxDegree; i++) {
		const c = character(i)
		edges.push({ from: "v", to: c })
	}
	// const seen = new Set<string>()
	let situationId = 0
	for (let rootColors = 0; rootColors < ROOT_COLOR_LIST_OPTIONS.length; rootColors++) {
		const C = ROOT_COLOR_LIST_OPTIONS[rootColors]
		const nodes: GraphNode[] = [{ id: "v", colors: C, role: "root" }]

		/**
		 * This function generates all stars with center vertex v and targetDegree leaves, assigning all
		 * possible non-isomorphic color list and half-edges to the leaves.
		 */
		function* backtrack(
			targetDegree: number,
			alreadyGenerated = 0,
			minJ = 0
		): Generator<GraphNode[]> {
			if (alreadyGenerated === targetDegree) {
				yield nodes
				return
			}
			for (const j of COMPATIBLE_COLOR_LISTS[rootColors]) {
				if (j < minJ) continue
				const D = COLOR_LIST_OPTIONS[j]
				const noDuplicates =
					REQUIRE_NO_TWO_SAME_AS_ROOT_LIST &&
					C.length === 2 &&
					D.length === 2 &&
					C[0] === D[0] &&
					C[1] === D[1]
						? 1
						: 0
				const minHalfedges = targetDegree === maxDegree ? targetDegree : 2
				const maxHalfedges = targetDegree === maxDegree ? targetDegree : targetDegree - 1
				for (let halfedges = minHalfedges; halfedges <= maxHalfedges; halfedges++) {
					nodes.push({
						id: character(alreadyGenerated + 1),
						colors: D,
						role: "separator",
						halfedges
					})
					const newMinJ = Math.max(j + noDuplicates, minJ)
					yield* backtrack(targetDegree, alreadyGenerated + 1, newMinJ)
					nodes.pop()
				}
			}
		}
		for (let targetDegree = minDegree; targetDegree <= maxDegree; targetDegree++) {
			for (const V of backtrack(targetDegree)) {
				const E = edges.slice(0, V.length - 1)
				const G = new Graph(V, E)

				// this HACK removes graphs that use colors 1,2,4, but not 3.
				const colorSet = new Set<number>()
				for (const n of G.nodes) for (const c of n.colors) colorSet.add(c)
				if (colorSet.size === 3) {
					const colors = Array.from(colorSet).sort()
					if (colors.join(",") !== "1,2,3") continue
				} else if (colorSet.size === 2) {
					const colors = Array.from(colorSet).sort()
					if (colors.join(",") !== "1,2") continue
				}

				yield { canon: G, situationId }
				situationId++
				// const canon = new Graph(V, E).canon()
				// if (!seen.has(canon.signature)) {
				// 	yield { ...canon, situationId: seen.size }
				// 	seen.add(canon.signature)
				// }
			}
		}
	}
}

let autogeneratedRuleCounter = 0

/**
 * Generate all possible branching rules for a given local situation. Note that in general, canon
 * may have multiple roots, and we only want to enumerate assignments that are compatible.
 */
export function autogenerateRules({
	canon,
	situationId
}: {
	canon: Graph
	situationId: number
}): BranchingRule[] {
	const roots = Array.from(canon.nodes).filter(node => node.role === "root")
	if (roots.length !== 1) return []

	const root = roots[0]
	if (root.colors.length === 0) return []

	const rules: BranchingRule[] = []

	if (root.colors.length >= 2) {
		const singletonBranches: BranchingRule["branches"] = root.colors.map(color => ({
			assignments: { [root.id]: [color] as readonly Color[] }
		}))
		rules.push({
			situationId,
			ruleId: autogeneratedRuleCounter,
			situationRuleId: rules.length,
			name: `Rule ${autogeneratedRuleCounter}`,
			description: `Auto-generated for situation #${situationId}`,
			before: canon,
			branches: singletonBranches
		})
		autogeneratedRuleCounter += 1
	}

	// one-rest split. Eg. 1,2,3 -> 1 | 2,3
	if (root.colors.length >= 3) {
		const neighborIds = Array.from(canon.neighbors(root.id)).toSorted((a, b) => a.localeCompare(b))
		const seenTypes = new Set<string>()
		for (const color of root.colors) {
			const typeKey = neighborIds.filter(id => canon.nodeById(id)?.colors.includes(color)).join("|")
			if (seenTypes.has(typeKey)) continue
			seenTypes.add(typeKey)
			const remaining = root.colors.filter(c => c !== color) as readonly Color[]
			const splitBranches: BranchingRule["branches"] = [
				{ assignments: { [root.id]: [color] as readonly Color[] } },
				{ assignments: { [root.id]: remaining } }
			]
			rules.push({
				situationId,
				ruleId: autogeneratedRuleCounter,
				situationRuleId: rules.length,
				name: `Rule ${autogeneratedRuleCounter}`,
				description: `Auto-generated for situation #${situationId}`,
				before: canon,
				branches: splitBranches
			})
			autogeneratedRuleCounter += 1
		}
	}

	// two-rest split. Eg. 1,2,3,4 -> 1,3 | 2,4
	if (root.colors.length >= 4) {
		const seenSplits = new Set<string>()
		for (let i = 0; i < root.colors.length; i++) {
			for (let j = i + 1; j < root.colors.length; j++) {
				const first = [root.colors[i], root.colors[j]] as readonly Color[]
				const second = root.colors.filter((_, idx) => idx !== i && idx !== j) as readonly Color[]
				const aKey = [...first].toSorted().join(",")
				const bKey = [...second].toSorted().join(",")
				const splitKey = aKey <= bKey ? `${aKey}|${bKey}` : `${bKey}|${aKey}`
				if (seenSplits.has(splitKey)) continue
				seenSplits.add(splitKey)
				const splitBranches: BranchingRule["branches"] = [
					{ assignments: { [root.id]: first } },
					{ assignments: { [root.id]: second } }
				]
				rules.push({
					situationId,
					ruleId: autogeneratedRuleCounter,
					situationRuleId: rules.length,
					name: `Rule ${autogeneratedRuleCounter}`,
					description: `Auto-generated for situation #${situationId}`,
					before: canon,
					branches: splitBranches
				})
				autogeneratedRuleCounter += 1
			}
		}
	}
	return rules
}
