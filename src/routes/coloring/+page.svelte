<script lang="ts">
	import { onDestroy } from "svelte"
	import { browser } from "$app/environment"
	import {
		computeFeatureVector,
		createFeatureVector,
		describeFeature,
		features,
		formatMeasure,
		subtractFeatureVectors,
		type FeatureVector,
		type PartialFeatureVector
	} from "$lib/coloring/featureSpace"
	import type { Graph } from "$lib/coloring/graph"
	import {
		analyzeRule,
		autogenerateRules,
		buildRecurrenceStrings,
		buildScalarRecurrence,
		describeAssignments,
		type BranchingRule,
		type BranchingRuleWithAnalysis
	} from "$lib/coloring/rule-engine"
	import { enumerateSituations, parseStarGraph } from "$lib/coloring/star-graph-enumeration"
	import BasicSubscripts from "$lib/components/BasicSubscripts.svelte"
	import GraphView from "$lib/components/GraphView.svelte"
	import { formatAsymptotics } from "$lib/polynomial-system-solver"
	import { solveRecurrencesFromStrings } from "$lib/recurrence-solver"
	import { formatMillis, formatNumber, formatPercent, map2D } from "$lib/utils"
	import { OptimizationManager } from "../../lib/vector-optimizer-manager"
	import {
		buildDefaultBounds,
		colorListSizeOptions,
		colorPaletteOptions,
		getFixedPartialMeasure,
		matchesColorListSizes,
		matchesColorPalette,
		type ColorListSizes,
		type ColorPalette,
		type LocalSituation
	} from "./coloring-logic"

	/**
	 * Memoized list of canonical situations (computed asynchronously for progress reporting).
	 */
	const ALL_LOCAL_SITUATIONS: LocalSituation[] = []

	/**
	 * Memoized list of autogenerated rules for each situation.
	 */
	const AUTOGENERATED_RULES: BranchingRule[][] = []

	/**
	 * Reactive state tracking the progress of situation computation.
	 */
	let localSituationsStatus = $state({
		loading: true,
		computed: 0,
		success: 0,
		elapsedMs: 0
	})

	/**
	 * Asynchronously computes all canonical local situations and their branching rules.
	 * Reports progress to the UI and yields to the main thread to keep the UI responsive.
	 */
	const computeSituations = async () => {
		if (!browser) return
		localSituationsStatus.loading = true
		localSituationsStatus.computed = 0
		localSituationsStatus.success = 0
		localSituationsStatus.elapsedMs = 0

		const start = performance.now()
		/**
		 * Yields control back to the UI thread.
		 */
		const yieldToUI = () =>
			new Promise<void>(resolve => {
				if (typeof requestAnimationFrame === "function") requestAnimationFrame(() => resolve())
				else setTimeout(resolve, 0)
			})

		let counter = 0
		for (const signature of enumerateSituations()) {
			const G = parseStarGraph(signature)
			const situation: LocalSituation = { canon: G, situationId: counter, signature }
			const rules = autogenerateRules(situation)
			ALL_LOCAL_SITUATIONS.push(situation)
			AUTOGENERATED_RULES.push(rules)
			counter += 1
			if (counter % 100 === 0) {
				localSituationsStatus.computed = counter
				await yieldToUI()
			}
		}
		localSituationsStatus.success = ALL_LOCAL_SITUATIONS.length
		localSituationsStatus.elapsedMs = performance.now() - start
		localSituationsStatus.loading = false
	}

	let selectedColorListSize = $state<ColorListSizes>("size23")
	let selectedPalette = $state<ColorPalette>("123")

	const fixedPartialMeasure = $derived(
		getFixedPartialMeasure(selectedPalette, selectedColorListSize)
	)
	const fixedPartialMeasureEntries = $derived(Object.entries(fixedPartialMeasure))

	const allowedColors = $derived(
		colorPaletteOptions.find(option => option.key === selectedPalette)?.colors ?? [1, 2, 3, 4]
	)
	const allowedSizes = $derived(
		colorListSizeOptions.find(option => option.key === selectedColorListSize)?.listSizes
	)
	const size234Disabled = $derived(selectedPalette === "123" || selectedPalette === "12")
	const size23Disabled = $derived(selectedPalette === "12")

	const problem = $derived(selectedPalette === "12" ? "independent set" : "list coloring")

	const analyzedRules = $derived(
		localSituationsStatus.loading
			? []
			: map2D(AUTOGENERATED_RULES, r =>
					analyzeRule(r, computeFeatureVector, subtractFeatureVectors, problem)
				)
	)

	/**
	 * Determines if a graph situation is "irreducible" under standard list-coloring reductions.
	 *
	 * For list coloring, if a vertex has a list of size 2 and two or more neighbors with the exact
	 * same list, the instance can be reduced.
	 *
	 * @param G - The graph situation to check.
	 * @returns True if the situation cannot be obviously reduced, false otherwise.
	 */
	function cannotReduceInstance(G: Graph): boolean {
		if (selectedPalette === "12") {
			return true
		}
		for (const u of G.nodes) {
			if (u.colors.length !== 2) continue
			let counter = 0
			for (const vId of G.neighbors[u.id]) {
				const v = G.nodeById[vId]
				if (v.colors.length === 2 && u.colors[0] === v.colors[0] && u.colors[1] === v.colors[1])
					counter += 1
			}
			if (counter > 1) return false
		}
		return true
	}

	const filteredLocalSituations = $derived(
		localSituationsStatus.loading
			? []
			: ALL_LOCAL_SITUATIONS.filter(x => matchesColorPalette(x.canon, allowedColors))
					.filter(x => matchesColorListSizes(x.canon, allowedSizes))
					.filter(x => cannotReduceInstance(x.canon))
					.map(x => x.situationId)
	)
	const displaySituations = $derived([...filteredLocalSituations.slice(0, 500)])
	const filteredRules = $derived(
		localSituationsStatus.loading ? [] : filteredLocalSituations.map(s => analyzedRules[s])
	)

	let userWeights = $state(createFeatureVector(1))
	let isWeightSearchRunning = $state(false)
	let weightSearchProgress = $state({ mode: "", phase: "", percent: 0 })

	let hoveredGraph = $state<Graph | null>(null)
	let tooltipPosition = $state({ x: 0, y: 0 })

	let lastBestWeights = $state<FeatureVector | null>(null)
	let lastBestBase = $state<number | null>(null)
	let currentSearchBounds = $state<null | {
		min: PartialFeatureVector
		max: PartialFeatureVector
	}>(null)

	const scalarRecurrences = $derived.by(() => {
		if (localSituationsStatus.loading) return []
		return map2D(analyzedRules, generatedGetRuleSolution)
	})

	const sortedDisplaySituations = $derived.by(() => {
		const sol = map2D(scalarRecurrences, ({ solution: x }) =>
			x?.ok ? (x.divergent ? Infinity : Object.values(x.root)[0]) : 0
		)
		return displaySituations.toSorted((a, b) => Math.min(...sol[b]) - Math.min(...sol[a]))
	})

	const limitingSituationId = $derived(sortedDisplaySituations[0])

	/**
	 * Manager for the optimization Web Worker.
	 */
	const optimizationManager = new OptimizationManager()

	/**
	 * Starts the weight optimization search using the current filtered rules and bounds.
	 */
	const handleStartSearch = () => {
		if (isWeightSearchRunning || filteredRules.length === 0) return

		isWeightSearchRunning = true
		currentSearchBounds = currentSearchBounds ?? buildDefaultBounds(fixedPartialMeasure)
		lastBestWeights = null
		lastBestBase = null
		weightSearchProgress = { mode: "Optimizing", phase: "Initializing...", percent: 0 }

		const ruleDeltasGroups = map2D(filteredRules, rule =>
			rule.branchDetails.map(b => ({ ...b.featuresDelta }))
		)
		optimizationManager.start({
			ruleDeltasGroups,
			bounds: currentSearchBounds,
			onProgress: percent => {
				weightSearchProgress.percent = percent
			},
			onPhase: phase => {
				weightSearchProgress.phase = phase
			},
			onBest: (w, value) => {
				if (lastBestBase === null || value < lastBestBase) {
					userWeights = w
					lastBestWeights = w
					lastBestBase = value
				}
			},
			onDone: () => {
				isWeightSearchRunning = false
				weightSearchProgress.phase = ""
			},
			onError: msg => {
				console.error(msg)
				isWeightSearchRunning = false
				weightSearchProgress.phase = ""
			}
		})
	}

	/**
	 * Computes the weighted recurrence and solution for a specific rule.
	 * @param rule - The analyzed branching rule.
	 * @returns An object containing the weighted recurrence and its solution, or null if not found.
	 */
	const generatedGetRuleSolution = (rule: BranchingRuleWithAnalysis) => {
		const deltas = rule.branchDetails.map(branch => branch.featuresDelta)
		const weighted = buildScalarRecurrence(deltas, userWeights)
		const solution = solveRecurrencesFromStrings(weighted.equation)
		return { weighted, solution }
	}

	onDestroy(() => {
		optimizationManager.stop()
	})

	$effect(() => {
		if (browser) queueMicrotask(computeSituations)
		else computeSituations()
	})

	$effect(() => {
		if (size234Disabled && selectedColorListSize === "size234") {
			selectedColorListSize = size23Disabled ? "size2" : "size23"
		}
		if (size23Disabled && selectedColorListSize === "size23") {
			selectedColorListSize = "size2"
		}
	})

	$effect(() => {
		optimizationManager.stop()
		isWeightSearchRunning = false
		lastBestWeights = null
		lastBestBase = null
		weightSearchProgress = { mode: "", phase: "", percent: 0 }
		currentSearchBounds = null
	})
</script>

<svelte:window
	onmousemove={e => {
		tooltipPosition = { x: e.clientX, y: e.clientY }
	}} />

<div class="mx-auto max-w-6xl space-y-12 sm:p-8">
	<h1 class="text-3xl font-bold">Branching Rules for List 3‑Coloring</h1>

	<p class="text-gray-700">
		Each rule below illustrates a local structure in a list-coloring instance, its branching
		options, and the resulting recurrence on the measures we track. After each rule you can inspect
		the recurrence, a weighted scalar reduction (when available), and the asymptotic solution
		produced by the recurrence solver.
	</p>
	<div class="rounded-lg border border-sky-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-sky-700 uppercase">Tasks</div>
		<div class="mt-3 space-y-3">
			<div class="flex items-start gap-3">
				<span
					class={localSituationsStatus.loading
						? "mt-0.5 inline-flex h-4 w-4 animate-spin rounded-full border-2 border-sky-400 border-t-transparent"
						: "mt-0.5 inline-flex h-4 w-4 rounded-full bg-emerald-500"}
					aria-hidden="true"></span>
				<div class="space-y-0.5">
					<div class="font-semibold">Computing canonical local situations</div>
					<div class="text-xs text-gray-600">
						{#if localSituationsStatus.loading}
							Computed {localSituationsStatus.computed} so far…
						{:else}
							Found {localSituationsStatus.success} situations in
							{formatMillis(localSituationsStatus.elapsedMs)}
						{/if}
					</div>
				</div>
			</div>
			<div class="flex items-start gap-3">
				{#if isWeightSearchRunning || filteredRules.length === 0}
					<span
						class="mt-0.5 inline-flex h-4 w-4 animate-spin rounded-full border-2 border-amber-400 border-t-transparent"
						aria-hidden="true"></span>
				{:else}
					<span class="mt-0.5 inline-flex h-4 w-4 rounded-full bg-emerald-500" aria-hidden="true"
					></span>
				{/if}
				<div class="space-y-0.5">
					<div class="font-semibold">Start optimization</div>
					<div class="text-xs text-gray-600">
						{#if isWeightSearchRunning}
							<div class="font-medium text-amber-700">{weightSearchProgress.phase}</div>
							{weightSearchProgress.mode}
							— {formatPercent(weightSearchProgress.percent * 100)} complete
						{:else if filteredRules.length === 0}
							Waiting for situations to generate…
						{:else if lastBestWeights}
							Completed latest optimization.
						{:else}
							Optimization not started.
						{/if}
					</div>
					<div class="pt-1">
						<button
							class="rounded bg-amber-600 px-3 py-2 text-xs font-semibold text-white uppercase shadow hover:bg-amber-700 disabled:cursor-not-allowed disabled:bg-amber-300"
							onclick={handleStartSearch}
							disabled={isWeightSearchRunning ||
								filteredRules.length === 0 ||
								localSituationsStatus.loading}>
							Start search
						</button>
						<p class="mt-2 max-w-xl text-xs text-gray-600">
							Heuristically find a measure that minimizes the base b in O(b<sup>μ</sup>) that upper
							bounds all recurrence relations; the best measure and limiting situation are
							summarized here.
						</p>
						{#if lastBestWeights && lastBestBase !== null}
							<div
								class="mt-2 rounded border border-amber-100 bg-amber-50 px-3 py-2 text-xs text-amber-900">
								<div class="font-semibold">Best so far</div>
								<div class="mt-1 flex flex-col gap-1">
									<div>
										Measure:
										<span class="font-mono text-amber-800">
											<BasicSubscripts raw={`μ = ${formatMeasure(lastBestWeights)}`} />
										</span>
									</div>
									<div>Base: O({formatNumber(lastBestBase)}<sup>μ</sup>)</div>
									{#if limitingSituationId !== null}
										<div>Limiting situation: #{limitingSituationId}</div>
										{#if !localSituationsStatus.loading && ALL_LOCAL_SITUATIONS[limitingSituationId]}
											<div class="mt-2 w-fit rounded border border-dotted bg-white p-2">
												<GraphView
													graph={ALL_LOCAL_SITUATIONS[limitingSituationId].canon}
													scale={0.6} />
											</div>
										{/if}
									{/if}
								</div>
							</div>
						{/if}
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="space-y-4 rounded-lg border border-indigo-200 bg-white p-4 text-sm text-gray-800">
		<div class="space-y-2">
			<div class="text-xs font-semibold tracking-wide text-indigo-700 uppercase">
				Choose the problem
			</div>
			<div class="grid gap-3 md:grid-cols-3">
				{#each colorPaletteOptions as option (option.key)}
					<label
						class="flex cursor-pointer items-start gap-3 rounded-md border border-gray-200 bg-gray-50 p-3 transition hover:border-indigo-400">
						<input
							type="radio"
							class="mt-1 h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
							name="color-palette"
							value={option.key}
							bind:group={selectedPalette} />
						<div class="space-y-1">
							<div class="text-sm font-semibold text-gray-800">{option.label}</div>
							<p class="text-xs text-gray-600">{option.description}</p>
						</div>
					</label>
				{/each}
			</div>
		</div>
		<div class="space-y-2">
			<div class="text-xs font-semibold tracking-wide text-indigo-700 uppercase">
				Restricted list size
			</div>
			<div class="grid gap-3 md:grid-cols-3">
				{#each colorListSizeOptions as option (option.key)}
					{@const disabled =
						(option.key === "size234" && size234Disabled) ||
						(option.key === "size23" && size23Disabled)}
					<label
						class={`flex items-start gap-3 rounded-md border border-gray-200 bg-gray-50 p-3 transition ${
							disabled ? "cursor-not-allowed opacity-60" : "cursor-pointer hover:border-indigo-400"
						}`}
						aria-disabled={disabled}>
						<input
							type="radio"
							class="mt-1 h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
							name="situation-variant"
							value={option.key}
							bind:group={selectedColorListSize}
							{disabled} />
						<div class="space-y-1">
							<div class="text-sm font-semibold text-gray-800">{option.label}</div>
							<p class="text-xs text-gray-600">{option.description}</p>
						</div>
					</label>
				{/each}
			</div>
			{#if fixedPartialMeasureEntries.length}
				<div class="rounded-md border border-indigo-100 bg-indigo-50/60 p-3 text-xs text-gray-700">
					<div class="font-semibold text-indigo-800">Fixed coefficients</div>
					<ul class="mt-2 space-y-1">
						{#each fixedPartialMeasureEntries as [feature, value] (feature)}
							<li class="flex items-center gap-2 font-mono">
								<BasicSubscripts raw={"coefficient." + feature} />
								<span class="text-gray-500">=</span>
								<span class="font-mono text-gray-800">{value}</span>
							</li>
						{/each}
					</ul>
				</div>
			{/if}
		</div>
	</div>

	<div class="rounded-lg border border-gray-300 bg-gray-50 p-4 text-sm text-gray-800">
		<div class="font-semibold tracking-wide text-gray-600 uppercase">Legend</div>
		<ul class="mt-2 list-disc space-y-1 pl-5">
			{#each features as f (f)}
				<li>
					<span class="font-mono"><BasicSubscripts raw={f} /></span> — {describeFeature(f)}
				</li>
			{/each}
		</ul>
	</div>

	<div class="rounded-lg border border-emerald-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-emerald-700 uppercase">Custom Measure</div>
		<p class="mt-2">
			Set the coefficients to define the scalar measure <span class="font-mono">μ</span> that the solver
			will use for every rule.
		</p>
		<div class="mt-4 grid gap-4 md:grid-cols-3">
			{#each features as f (f)}
				<label class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600">
					<span><span class="uppercase">Coefficient of</span> <BasicSubscripts raw={f} /></span>
					<input
						type="number"
						min="0"
						step="0.1"
						class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
						bind:value={userWeights[f]} />
				</label>
			{/each}
		</div>
		<p class="mt-3 text-xs text-gray-500">
			Current measure:
			<span class="font-mono">μ = <BasicSubscripts raw={formatMeasure(userWeights)} /></span>
		</p>
		{#if isWeightSearchRunning}
			<div class="mt-3 flex items-center gap-2 text-xs font-semibold text-emerald-700">
				<span
					class="inline-flex h-4 w-4 animate-spin rounded-full border-2 border-emerald-400 border-t-transparent"
					aria-hidden="true"></span>
				<span>Searching optimal weights…</span>
			</div>
		{/if}
	</div>

	<section class="space-y-6 rounded-xl border border-gray-300 bg-white p-6">
		<header class="space-y-2">
			<h2 class="text-xl font-semibold">Canonical situations</h2>
			<p class="text-gray-600">
				Showing {filteredLocalSituations.length} situations filtered by scope and palette. Each card lists
				the rules available for that situation.
			</p>
		</header>

		<div class="grid gap-6 md:grid-cols-2">
			{#await sortedDisplaySituations}
				Waiting
			{:then x}
				{#each x as s (ALL_LOCAL_SITUATIONS[s].signature)}
					{@const rulesForSituation = analyzedRules[s] ?? []}
					<div class="space-y-4 rounded-lg border bg-gray-50 p-4">
						<div class="flex items-start justify-between gap-3">
							<div class="space-y-1">
								<div class="font-semibold tracking-wide text-gray-800 uppercase">
									Situation #{s}
								</div>
								<div class="font-mono text-gray-600">
									{ALL_LOCAL_SITUATIONS[s].signature}
								</div>
							</div>
						</div>

						<div class="w-fit rounded border border-dotted bg-white p-2">
							<GraphView graph={ALL_LOCAL_SITUATIONS[s].canon} scale={0.6} />
						</div>

						<div class="space-y-3">
							{#if rulesForSituation.length === 0}
								<p class="text-xs text-gray-500">No rules available for this situation.</p>
							{:else}
								{#each rulesForSituation as rule (rule.ruleId)}
									{@const solved = scalarRecurrences[rule.situationId][rule.ruleId]}
									<div
										class="space-y-2 rounded border border-dashed bg-white p-3 text-sm text-gray-800">
										<span class="font-semibold tracking-wide uppercase">Rule {rule.ruleId}:</span>
										<div class="flex flex-wrap items-baseline gap-2 text-sm">
											<div class="space-y-2">
												{#each rule.branches as branch, idx (branch.assignments)}
													{@const details = rule.branchDetails[idx]}
													<!-- svelte-ignore a11y_no_static_element_interactions -->
													<div
														class="flex gap-2 hover:bg-red-100"
														onmouseenter={() => (hoveredGraph = details.after)}
														onmouseleave={() => (hoveredGraph = null)}>
														<div>{describeAssignments(branch.assignments)}</div>
														<div class="text-gray-400">|</div>
														<!-- svelte-ignore a11y_no_static_element_interactions -->
														<div>
															<BasicSubscripts
																raw={buildRecurrenceStrings([details.featuresDelta], true)} />
														</div>
													</div>
												{/each}
											</div>
										</div>
										{#if solved?.weighted}
											<div class="space-y-2">
												<div>{solved.weighted.equation}</div>
												<div>
													<span>Solution:</span>
													<span>
														{#if solved.weighted.decreasing}
															{#await solved.solution}
																<span class="text-gray-500">Computing…</span>
															{:then solution}
																{#if solution?.ok && !solution?.divergent}
																	{formatAsymptotics(solution.root)}
																{:else if solution?.ok}
																	Divergent
																{:else}
																	<span class="text-red-600"
																		>Solver error: {solution?.error ?? "unknown"}</span>
																{/if}
															{:catch error}
																<span class="text-red-600"
																	>Unknown error: {error instanceof Error
																		? error.message
																		: String(error)}</span>
															{/await}
														{:else}
															Divergent
														{/if}
													</span>
												</div>
											</div>
										{/if}
									</div>
								{/each}
							{/if}
						</div>
					</div>
				{/each}
			{/await}
		</div>
		<!-- <pre>
{localSituationsStatus.loading ? "Getting ready..." : JSON.stringify(ALL_LOCAL_SITUATIONS)}
		</pre> -->
	</section>
</div>

{#if hoveredGraph}
	<div
		class="fixed z-50 rounded-lg border border-gray-200 bg-white p-2 shadow-xl"
		style="top: {tooltipPosition.y + 16}px; left: {tooltipPosition.x + 16}px;">
		<div class="mb-1 text-xs font-semibold text-gray-500">Resulting Graph</div>
		<GraphView graph={hoveredGraph} scale={0.7} />
	</div>
{/if}
