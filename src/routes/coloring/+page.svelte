<script lang="ts">
	import { onDestroy } from "svelte"
	import { SvelteMap } from "svelte/reactivity"
	import { browser } from "$app/environment"
	import { autogenerateRules, generateAllLocalSituations } from "$lib/coloring/3coloring-rules"
	import type { Graph } from "$lib/coloring/graph-utils"
	import {
		analyzeRule,
		describeAssignments,
		type BranchingRuleWithAnalysis,
		type WeightVector
	} from "$lib/coloring/rule-engine"
	import GraphView from "$lib/components/GraphView.svelte"
	import { formatAsymptotics } from "$lib/root-finding"
	import {
		buildRecurrenceSolutionsForWeights,
		buildWeightedRecurrencesForWeights,
		formatWeight,
		GRID_AXIS_COUNT,
		GRID_SEARCH_STEP,
		ruleColorPalette,
		weightIndex,
		type WeightGridCell
	} from "./weight-grid-shared"
	import type { GridWorkerDoneMessage, GridWorkerInput, GridWorkerMessage } from "./worker"

	type SituationVariant = "all" | "size2Only" | "withSize3"
	type ColorPalette = "123" | "1234"
	type DegreeOption = "strict3" | "mixed34"

	/**
	 * Memoized list of canonical situations (computed asynchronously for progress reporting).
	 */
	const ALL_LOCAL_SITUATIONS: { canon: Graph; situationId: number }[] = []
	const AUTOGENERATED_RULES: BranchingRuleWithAnalysis[][] = []
	let localSituationsStatus = $state({
		loading: true,
		computed: 0,
		success: 0,
		elapsedMs: 0
	})

	const variantOptions: Array<{
		key: SituationVariant
		label: string
		description: string
	}> = [
		{
			key: "all",
			label: "All local situations",
			description: "Enumerate every canonical neighborhood."
		},
		{
			key: "size2Only",
			label: "Only lists of size 2",
			description: "Keep situations where every node has a two-color list."
		},
		{
			key: "withSize3",
			label: "At least one list of size 3",
			description: "Keep situations that include at least one three-color list."
		}
	]

	const colorPaletteOptions: Array<{
		key: ColorPalette
		label: string
		description: string
		colors: readonly number[]
	}> = [
		{
			key: "123",
			label: "List 3-Coloring",
			description: "Color Palette = {1,2,3}",
			colors: [1, 2, 3]
		},
		{
			key: "1234",
			label: "List 4-Coloring",
			description: "Color Palette = {1,2,3,4}",
			colors: [1, 2, 3, 4]
		}
	]

	const degreeOptions: Array<{
		key: DegreeOption
		label: string
		description: string
		minDegree: number
		maxDegree: number
	}> = [
		{
			key: "mixed34",
			label: "Mixed degree 3 and 4.",
			description:
				"Analyze degree-3 and degree-4 situations. Preferentially branch on degree-4 vertices.",
			minDegree: 3,
			maxDegree: 4
		},
		{
			key: "strict3",
			label: "Strict degree-3",
			description:
				"Analyze only degree-3 vertices (this won't consider the effect on the degree of the neighbors).",
			minDegree: 3,
			maxDegree: 3
		}
	]

	const formatMillis = (ms: number) => {
		if (!Number.isFinite(ms)) return "-"
		if (ms < 1000) return `${ms.toFixed(1)} ms`
		return `${(ms / 1000).toFixed(2)} s`
	}

	const computeSituations = async (minDegree: number, maxDegree: number) => {
		localSituationsStatus.loading = true
		localSituationsStatus.computed = 0
		localSituationsStatus.success = 0
		localSituationsStatus.elapsedMs = 0

		const start = performance.now()
		let counter = 0
		const yieldToUI = () =>
			new Promise<void>(resolve => {
				if (typeof requestAnimationFrame === "function") requestAnimationFrame(() => resolve())
				else setTimeout(resolve, 0)
			})
		for (const situation of generateAllLocalSituations(minDegree, maxDegree)) {
			ALL_LOCAL_SITUATIONS.push(situation)
			AUTOGENERATED_RULES.push(autogenerateRules(situation).map(analyzeRule))
			counter += 1
			localSituationsStatus.computed = counter
			if (counter % 25 === 0) await yieldToUI()
		}
		localSituationsStatus.success = ALL_LOCAL_SITUATIONS.length
		localSituationsStatus.elapsedMs = performance.now() - start
		localSituationsStatus.loading = false
	}
	let selectedVariant = $state<SituationVariant>("all")
	let selectedPalette = $state<ColorPalette>("123")
	let selectedDegree = $state<DegreeOption>("mixed34")

	const allowedColors = $derived(
		colorPaletteOptions.find(option => option.key === selectedPalette)?.colors ?? [1, 2, 3, 4]
	)

	const extractListSizes = (group: BranchingRuleWithAnalysis[]) => {
		const firstRule = group[0]
		if (!firstRule) return null
		return Array.from(firstRule.before.nodes).map(node => node.colors.length)
	}

	const matchesPalette = (group: BranchingRuleWithAnalysis[]) => {
		const firstRule = group[0]
		if (!firstRule) return false
		return Array.from(firstRule.before.nodes).every(node =>
			node.colors.every(color => allowedColors.includes(color))
		)
	}

	const matchesVariant = (group: BranchingRuleWithAnalysis[], variant: SituationVariant) => {
		if (variant === "all") return true
		const sizes = extractListSizes(group)
		if (!sizes) return false
		if (variant === "size2Only") return sizes.every(size => size === 2)
		return sizes.some(size => size === 3)
	}

	const ruleGroups = $derived(
		localSituationsStatus.loading
			? []
			: AUTOGENERATED_RULES.filter(group => matchesVariant(group, selectedVariant)).filter(group =>
					matchesPalette(group)
				)
	)
	const rulesBySituation = $derived(
		new Map(
			ruleGroups
				.filter(group => group.length > 0)
				.map(group => [group[0].situationId, group] as const)
		)
	)

	const colorFilteredSituations = $derived(
		localSituationsStatus.loading
			? []
			: ALL_LOCAL_SITUATIONS.filter(({ canon }) =>
					Array.from(canon.nodes).every(node =>
						node.colors.every(color => allowedColors.includes(color))
					)
				)
	)

	const targetSituations = $derived.by(() => {
		const source = colorFilteredSituations
		if (selectedVariant === "all") return source
		return source.filter(({ canon }) => {
			const sizes = Array.from(canon.nodes).map(node => node.colors.length)
			if (selectedVariant === "size2Only") return sizes.every(size => size === 2)
			return sizes.some(size => size === 3)
		})
	})

	// const exhaustivenessReport = $derived.by(() => {
	// 	const coverage = new SvelteSet<string>()
	// 	for (const rule of allRules) {
	// 		const { signature } = rule.before.canon()
	// 		coverage.add(signature)
	// 	}
	// 	const missing = targetSituations
	// 		.filter(situation => !coverage.has(situation.signature))
	// 		.map(entry => entry.canon)
	// 	const coveredCount = targetSituations.reduce(
	// 		(count, situation) => count + (coverage.has(situation.signature) ? 1 : 0),
	// 		0
	// 	)
	// 	return {
	// 		exhaustive: missing.length === 0,
	// 		missing,
	// 		missingCount: missing.length,
	// 		coveredCount,
	// 		totalSituations: targetSituations.length
	// 	}
	// })
	// const missingRuleSnippets = $derived(buildMissingRuleSnippets(exhaustivenessReport))

	const MAX_CANVAS_RENDER_PX = 420

	const formatPercent = (num: number) => `${num.toFixed(1)}%`

	let userWeights = $state<WeightVector>({ w4: 1, w3: 1, w2: 0.6241 })
	let isWeightSearchRunning = $state(false)
	let weightGrid = $state<(WeightGridCell | null)[]>(Array(GRID_AXIS_COUNT).fill(null))
	let weightSearchProgress = $state({ total: 0, completed: 0, mode: "" })

	// Precompute recurrence + solutions for all generated rules (unfiltered), preserving situation grouping.
	const generatedWeightedRecurrences = $derived.by(() =>
		localSituationsStatus.loading
			? []
			: AUTOGENERATED_RULES.map(group => buildWeightedRecurrencesForWeights(userWeights, group))
	)
	const generatedRecurrenceSolutions = $derived.by(() =>
		generatedWeightedRecurrences.map(group =>
			buildRecurrenceSolutionsForWeights(userWeights, group)
		)
	)

	let worker: Worker | null = null
	let searchVersion = 0

	let canvasEl: HTMLCanvasElement | null = null
	let ctx: CanvasRenderingContext2D | null = null
	let overlayCanvasEl: HTMLCanvasElement | null = null
	let overlayCtx: CanvasRenderingContext2D | null = null
	let imageData: ImageData | null = null
	let canvasDirty = false
	let flushScheduled = false
	let renderScale = 1
	let pendingHover: { x: number; y: number } | null = null
	let overlayDrawScheduled = false
	let lastDrawn: { x: number; y: number } | null = null
	let pendingCells: Array<{
		x: number
		y: number
		radius: number
		color: [number, number, number]
	}> = []
	let cellDrawScheduled = false
	const cellCache = new SvelteMap<number, WeightGridCell>()
	const w2ColumnCache = new SvelteMap<number, WeightGridCell>()
	let hoveredCell = $state<WeightGridCell | null>(null)
	let autoHoverCell: WeightGridCell | null = null
	let autoHoverBase: number | null = null
	let pointerActive = false
	const PENDING_RGB: [number, number, number] = [255, 255, 255]
	let resizeListener: (() => void) | null = null

	const hexToRgb = (hex: string): [number, number, number] => {
		const normalized = hex.replace("#", "")
		const num = parseInt(normalized, 16)
		return [(num >> 16) & 255, (num >> 8) & 255, num & 255]
	}

	const clampBaseValue = (base: number | null) => {
		if (base === null || Number.isNaN(base)) return 3
		if (base > 3) return 3
		if (base < 1) return 1
		return base
	}

	const baseToIndex = (base: number | null, axisCount: number = GRID_AXIS_COUNT) => {
		const clamped = clampBaseValue(base)
		const normalized = (clamped - 1) / 2
		const forward = Math.round(normalized * (axisCount - 1))
		return Math.min(axisCount - 1, Math.max(0, axisCount - 1 - forward))
	}

	const writePixel = (x: number, y: number, [r, g, b]: [number, number, number]) => {
		if (!imageData) return
		const idx = (y * GRID_AXIS_COUNT + x) * 4
		imageData.data[idx] = r
		imageData.data[idx + 1] = g
		imageData.data[idx + 2] = b
		imageData.data[idx + 3] = 255
	}

	const clearCanvasBuffer = () => {
		if (!imageData) return
		for (let i = 0; i < imageData.data.length; i += 4) {
			imageData.data[i] = PENDING_RGB[0]
			imageData.data[i + 1] = PENDING_RGB[1]
			imageData.data[i + 2] = PENDING_RGB[2]
			imageData.data[i + 3] = 255
		}
		canvasDirty = true
		scheduleFlushCanvas()
	}

	const scheduleFlushCanvas = () => {
		if (flushScheduled || !canvasDirty) return
		flushScheduled = true
		requestAnimationFrame(() => {
			flushScheduled = false
			if (ctx && imageData && canvasDirty) {
				ctx.putImageData(imageData, 0, 0)
				canvasDirty = false
			}
			if (canvasDirty) scheduleFlushCanvas()
		})
	}

	const initCanvas = () => {
		if (!canvasEl || !overlayCanvasEl) return
		ctx = canvasEl.getContext("2d")
		overlayCtx = overlayCanvasEl.getContext("2d")
		if (!ctx || !overlayCtx) return
		if (resizeListener) {
			window.removeEventListener("resize", resizeListener)
			resizeListener = null
		}
		ctx.imageSmoothingEnabled = false
		overlayCtx.imageSmoothingEnabled = false
		canvasEl.width = GRID_AXIS_COUNT
		canvasEl.height = GRID_AXIS_COUNT
		overlayCanvasEl.width = GRID_AXIS_COUNT
		overlayCanvasEl.height = GRID_AXIS_COUNT
		canvasEl.style.imageRendering = "pixelated"
		overlayCanvasEl.style.imageRendering = "pixelated"
		const resize = () => {
			const parentWidth =
				canvasEl?.parentElement?.clientWidth ?? canvasEl?.clientWidth ?? GRID_AXIS_COUNT
			const renderSize = Math.min(parentWidth, MAX_CANVAS_RENDER_PX)
			renderScale = renderSize / GRID_AXIS_COUNT
			canvasEl!.style.width = `${renderSize}px`
			canvasEl!.style.height = `${renderSize}px`
			overlayCanvasEl!.style.width = `${renderSize}px`
			overlayCanvasEl!.style.height = `${renderSize}px`
		}
		resize()
		resizeListener = () => resize()
		window.addEventListener("resize", resizeListener)
		imageData = ctx.createImageData(GRID_AXIS_COUNT, GRID_AXIS_COUNT)
		clearCanvasBuffer()
	}

	const writeCellToBuffer = (x: number, y: number) => {
		if (!imageData) return
		const radius = Math.max(1, Math.round(1 / Math.max(renderScale, 0.0001)))
		const color = hexToRgb(ruleColorPalette[0])
		pendingCells.push({ x, y, radius, color })
		if (cellDrawScheduled) return
		cellDrawScheduled = true
		requestAnimationFrame(() => {
			if (!imageData) {
				cellDrawScheduled = false
				return
			}
			while (pendingCells.length) {
				const { x: cx, y: cy, radius: r, color } = pendingCells.pop()!
				const yStart = Math.max(0, cy - r)
				const yEnd = Math.min(GRID_AXIS_COUNT - 1, cy + r)
				const xStart = Math.max(0, cx - r)
				const xEnd = Math.min(GRID_AXIS_COUNT - 1, cx + r)
				for (let ny = yStart; ny <= yEnd; ny++) {
					for (let nx = xStart; nx <= xEnd; nx++) {
						writePixel(nx, ny, color)
					}
				}
			}
			canvasDirty = true
			scheduleFlushCanvas()
			cellDrawScheduled = false
		})
	}

	const handleCanvasHover = (event: MouseEvent) => {
		if (!canvasEl) return
		const rect = canvasEl.getBoundingClientRect()
		const scale = rect.width / GRID_AXIS_COUNT
		const x = Math.floor((event.clientX - rect.left) / scale)
		if (x < 0 || x >= GRID_AXIS_COUNT) {
			pointerActive = false
			applyAutoHover()
			return
		}
		const cell = w2ColumnCache.get(x)
		if (!cell) {
			pointerActive = false
			applyAutoHover()
			return
		}
		pointerActive = true
		hoveredCell = cell
		const base = cell.maxBase
		const y = baseToIndex(base)
		drawHoverLine(x, y)
	}

	const clearOverlay = () => {
		if (!overlayCtx || !overlayCanvasEl) return
		overlayCtx.clearRect(0, 0, overlayCanvasEl.width, overlayCanvasEl.height)
		lastDrawn = null
	}

	const drawHoverLine = (x: number, y: number) => {
		if (!overlayCtx || !overlayCanvasEl) return
		if (lastDrawn && lastDrawn.x === x && lastDrawn.y === y) return
		pendingHover = { x, y }
		if (overlayDrawScheduled) return
		overlayDrawScheduled = true
		requestAnimationFrame(() => {
			if (!overlayCtx || !overlayCanvasEl || !pendingHover) {
				overlayDrawScheduled = false
				return
			}
			const { x: px, y: py } = pendingHover
			pendingHover = null
			clearOverlay()
			overlayCtx.strokeStyle = "rgba(17, 24, 39, 0.6)"
			const width = Math.max(2, Math.round(2 / Math.max(renderScale, 0.0001)))
			overlayCtx.lineWidth = width
			overlayCtx.beginPath()
			overlayCtx.moveTo(px + 0.5, GRID_AXIS_COUNT - 0.5)
			overlayCtx.lineTo(px + 0.5, py + 0.5)
			overlayCtx.stroke()
			lastDrawn = { x: px, y: py }
			overlayDrawScheduled = false
		})
	}

	const applyAutoHover = () => {
		if (!autoHoverCell) {
			clearOverlay()
			hoveredCell = null
			return
		}
		const base = autoHoverBase ?? autoHoverCell.maxBase
		if (base === null) {
			clearOverlay()
			hoveredCell = autoHoverCell
			return
		}
		const j = weightIndex(autoHoverCell.w.w2)
		const y = baseToIndex(base)
		hoveredCell = autoHoverCell
		drawHoverLine(j, y)
	}

	const resetGridState = () => {
		weightGrid = Array(GRID_AXIS_COUNT).fill(null)
		canvasDirty = false
		flushScheduled = false
		cellCache.clear()
		w2ColumnCache.clear()
		autoHoverCell = null
		autoHoverBase = null
		hoveredCell = null
		pointerActive = false
		pendingHover = null
		lastDrawn = null
		pendingCells = []
		cellDrawScheduled = false
		overlayDrawScheduled = false
	}

	const ensureCanvasReady = () => {
		if (!ctx || !overlayCtx || !imageData) initCanvas()
	}

	const restartWeightSearch = () => {
		if (!browser) return
		if (!canvasEl || !overlayCanvasEl) return
		const version = ++searchVersion
		worker?.terminate()
		worker = null
		ensureCanvasReady()
		resetGridState()
		clearOverlay()
		clearCanvasBuffer()
		isWeightSearchRunning = true
		let best: { weights: WeightVector | null; base: number } = {
			weights: null,
			base: Infinity
		}
		worker = new Worker(new URL("./worker.ts", import.meta.url), { type: "module" })
		worker.onmessage = (event: MessageEvent<GridWorkerMessage>) => {
			if (version !== searchVersion) return
			const message = event.data
			if (message.type === "cell") {
				const { cell } = message
				weightSearchProgress.completed = Math.min(
					weightSearchProgress.completed + 1,
					weightSearchProgress.total
				)
				const base = cell.maxBase
				const i = baseToIndex(base)
				const j = weightIndex(cell.w.w2)
				weightGrid[j] = cell
				cellCache.set(j, cell)
				w2ColumnCache.set(j, cell)
				writeCellToBuffer(j, i)
				if (base !== null && (autoHoverBase === null || base < autoHoverBase)) {
					autoHoverBase = base
					autoHoverCell = cell
					if (!pointerActive) {
						hoveredCell = autoHoverCell
						drawHoverLine(j, i)
					}
				}
				if (base !== null && (best.weights === null || base < best.base)) {
					best = { weights: cell.w, base }
				}
			} else if (message.type === "done") {
				const { bestWeights } = message as GridWorkerDoneMessage
				if (bestWeights) userWeights = bestWeights
				isWeightSearchRunning = false
			} else if (message.type === "error") {
				console.error(message.message)
				isWeightSearchRunning = false
			}
		}
		worker.onerror = err => {
			if (version !== searchVersion) return
			console.error(err)
			isWeightSearchRunning = false
		}
		const payload: GridWorkerInput = {
			type: "start",
			axisCount: GRID_AXIS_COUNT,
			step: GRID_SEARCH_STEP,
			ruleGroups: [...ruleGroups],
			w: { w4: 1, w3: selectedPalette === "1234" ? undefined : 1 }
		}
		const w4Count = payload.w?.w4 !== undefined ? 1 : (payload.axisCount ?? GRID_AXIS_COUNT)
		const w3Count = payload.w?.w3 !== undefined ? 1 : (payload.axisCount ?? GRID_AXIS_COUNT)
		const w2Count = payload.w?.w2 !== undefined ? 1 : (payload.axisCount ?? GRID_AXIS_COUNT)
		const totalCells = w4Count * w3Count * w2Count
		const mode =
			w4Count === 1 && w3Count === 1
				? "w₂ sweep"
				: w4Count === 1
					? "w₃ × w₂ sweep"
					: "w₄ × w₃ × w₂ sweep"
		weightSearchProgress = { total: totalCells, completed: 0, mode }
		worker.postMessage(payload)
	}

	const generatedGetRuleSolution = (rule: BranchingRuleWithAnalysis) => {
		const situationIdx = rule.situationId
		const ruleIdx = rule.situationRuleId
		if (
			situationIdx === undefined ||
			situationIdx === null ||
			situationIdx < 0 ||
			!Number.isInteger(situationIdx) ||
			ruleIdx === undefined ||
			ruleIdx === null ||
			ruleIdx < 0
		)
			return null
		const weighted = generatedWeightedRecurrences[situationIdx]?.[ruleIdx] ?? null
		const solution = generatedRecurrenceSolutions[situationIdx]?.[ruleIdx] ?? null
		return { weighted, solution }
	}

	const unresolvedSituations = $derived.by(() => {
		return ruleGroups
			.map(group => {
				if (group.length === 0) return null
				const situationId = group[0]?.situationId
				if (situationId === undefined || situationId === null) return null
				const recurrences = generatedWeightedRecurrences[situationId]
				if (!recurrences) return situationId
				let hasDecreasingRule = false
				for (let i = 0; i < group.length; i += 1) {
					const rule = group[i]
					const ruleIdx = rule.situationRuleId
					const weighted = recurrences[ruleIdx] ?? null
					if (weighted) {
						hasDecreasingRule = true
						break
					}
				}
				if (hasDecreasingRule) return null
				return situationId
			})
			.filter((id): id is number => id !== null)
	})

	const limitingCell = $derived.by(() => {
		const j = weightIndex(userWeights.w2)
		return w2ColumnCache.get(j) ?? null
	})

	const hoveredRule = $derived.by(() => {
		if (!hoveredCell) return null
		const group = AUTOGENERATED_RULES[hoveredCell.limitingSituationId]
		if (localSituationsStatus.loading || !group) return null
		return group.find(r => r.ruleId === hoveredCell?.limitingRuleId) ?? null
	})

	onDestroy(() => {
		if (resizeListener) {
			window.removeEventListener("resize", resizeListener)
			resizeListener = null
		}
		worker?.terminate()
		worker = null
	})

	$effect(() => {
		const task = () => {
			computeSituations(3, 4)
		}
		if (browser) queueMicrotask(task)
		else task()
	})

	$effect(() => {
		if (ruleGroups.length === 0) return
		restartWeightSearch()
	})
</script>

<div class="mx-auto max-w-6xl space-y-12 sm:p-8">
	<h1 class="text-3xl font-bold">Branching Rules for List 3‑Coloring</h1>

	<p class="text-gray-700">
		Each rule below illustrates a local structure in a list-coloring instance, its branching
		options, and the resulting recurrence on the measures we track. After each rule you can inspect
		the recurrence, a weighted scalar reduction (when available), and the asymptotic solution
		produced by the recurrence solver.
	</p>
	<div class="rounded-lg border border-sky-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-sky-700 uppercase">Tasks</div>
		<div class="mt-3 space-y-3">
			<div class="flex items-start gap-3">
				<span
					class={localSituationsStatus.loading
						? "mt-0.5 inline-flex h-4 w-4 animate-spin rounded-full border-2 border-sky-400 border-t-transparent"
						: "mt-0.5 inline-flex h-4 w-4 rounded-full bg-emerald-500"}
					aria-hidden="true"></span>
				<div class="space-y-0.5">
					<div class="font-semibold">Compute canonical local situations</div>
					<div class="text-xs text-gray-600">
						{#if localSituationsStatus.loading}
							Computed {localSituationsStatus.computed} so far…
						{:else}
							Found {localSituationsStatus.success} situations in
							{formatMillis(localSituationsStatus.elapsedMs)}
						{/if}
					</div>
				</div>
			</div>
			<div class="flex items-start gap-3">
				{#if isWeightSearchRunning || ruleGroups.length === 0}
					<span
						class="mt-0.5 inline-flex h-4 w-4 animate-spin rounded-full border-2 border-amber-400 border-t-transparent"
						aria-hidden="true"></span>
				{:else}
					<span class="mt-0.5 inline-flex h-4 w-4 rounded-full bg-emerald-500" aria-hidden="true"
					></span>
				{/if}
				<div class="space-y-0.5">
					<div class="font-semibold">Grid search</div>
					<div class="text-xs text-gray-600">
						{#if isWeightSearchRunning}
							{weightSearchProgress.mode}
							{#if weightSearchProgress.total > 0}
								— {formatPercent(
									(weightSearchProgress.completed / weightSearchProgress.total) * 100
								)} complete
							{/if}
						{:else if ruleGroups.length === 0}
							Waiting for situations to generate…
						{:else}
							Completed latest grid search.
						{/if}
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="space-y-4 rounded-lg border border-indigo-200 bg-white p-4 text-sm text-gray-800">
		<div class="space-y-2">
			<div class="text-xs font-semibold tracking-wide text-indigo-700 uppercase">
				Choose the problem
			</div>
			<div class="grid gap-3 md:grid-cols-3">
				{#each colorPaletteOptions as option (option.key)}
					<label
						class="flex cursor-pointer items-start gap-3 rounded-md border border-gray-200 bg-gray-50 p-3 transition hover:border-indigo-400">
						<input
							type="radio"
							class="mt-1 h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
							name="color-palette"
							value={option.key}
							bind:group={selectedPalette} />
						<div class="space-y-1">
							<div class="text-sm font-semibold text-gray-800">{option.label}</div>
							<p class="text-xs text-gray-600">{option.description}</p>
						</div>
					</label>
				{/each}
			</div>
		</div>
		<div class="space-y-2">
			<div class="text-xs font-semibold tracking-wide text-indigo-700 uppercase">
				Choose the degrees
			</div>
			<div class="grid gap-3 md:grid-cols-2">
				{#each degreeOptions as option (option.key)}
					<label
						class="flex cursor-pointer items-start gap-3 rounded-md border border-gray-200 bg-gray-50 p-3 transition hover:border-indigo-400">
						<input
							type="radio"
							class="mt-1 h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
							name="degree-option"
							value={option.key}
							bind:group={selectedDegree} />
						<div class="space-y-1">
							<div class="text-sm font-semibold text-gray-800">{option.label}</div>
							<p class="text-xs text-gray-600">{option.description}</p>
						</div>
					</label>
				{/each}
			</div>
		</div>
		<div class="space-y-2">
			<div class="text-xs font-semibold tracking-wide text-indigo-700 uppercase">
				Restricted Problem
			</div>
			<div class="grid gap-3 md:grid-cols-3">
				{#each variantOptions as option (option.key)}
					<label
						class="flex cursor-pointer items-start gap-3 rounded-md border border-gray-200 bg-gray-50 p-3 transition hover:border-indigo-400">
						<input
							type="radio"
							class="mt-1 h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
							name="situation-variant"
							value={option.key}
							bind:group={selectedVariant} />
						<div class="space-y-1">
							<div class="text-sm font-semibold text-gray-800">{option.label}</div>
							<p class="text-xs text-gray-600">{option.description}</p>
						</div>
					</label>
				{/each}
			</div>
		</div>
	</div>

	<div class="rounded-lg border border-gray-300 bg-gray-50 p-4 text-sm text-gray-800">
		<div class="font-semibold tracking-wide text-gray-600 uppercase">Legend</div>
		<ul class="mt-2 list-disc space-y-1 pl-5">
			<li>
				<span class="font-mono">n₄</span> — number of vertices whose lists contain four colors and whose
				degree is at least three.
			</li>
			<li>
				<span class="font-mono">n₃</span> — number of vertices whose lists contain three colors and whose
				degree is at least three.
			</li>
			<li>
				<span class="font-mono">n₂</span> — number of vertices whose lists contain two colors and whose
				degree is at least three.
			</li>
		</ul>
		<p>(Separator vertices are assumed to have degree at least three.)</p>
	</div>

	<div class="rounded-lg border border-emerald-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-emerald-700 uppercase">Custom Measure</div>
		<p class="mt-2">
			Set the coefficients for <span class="font-mono">n₄</span>,
			<span class="font-mono">n₃</span>, and
			<span class="font-mono">n₂</span>
			to define the scalar measure <span class="font-mono">n = w₄·n₄ + w₃·n₃ + w₂·n₂</span> that the solver
			will use for every rule.
		</p>
		<div class="mt-4 grid gap-4 md:grid-cols-3">
			<label class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600">
				<span><span class="uppercase">Coefficient</span> w₄</span>
				<input
					type="number"
					min="0"
					step="0.1"
					class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
					bind:value={userWeights.w4} />
			</label>
			<label class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600">
				<span><span class="uppercase">Coefficient</span> w₃</span>
				<input
					type="number"
					min="0"
					step="0.1"
					class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
					bind:value={userWeights.w3} />
			</label>
			<label class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600">
				<span><span class="uppercase">Coefficient</span> w₂</span>
				<input
					type="number"
					min="0"
					step="0.1"
					class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
					bind:value={userWeights.w2} />
			</label>
		</div>
		<p class="mt-3 text-xs text-gray-500">
			Current measure:
			<span class="font-mono"
				>n = {userWeights.w4}·n₄ + {userWeights.w3}·n₃ + {userWeights.w2}·n₂</span>
		</p>
		{#if isWeightSearchRunning}
			<div class="mt-3 flex items-center gap-2 text-xs font-semibold text-emerald-700">
				<span
					class="inline-flex h-4 w-4 animate-spin rounded-full border-2 border-emerald-400 border-t-transparent"
					aria-hidden="true"></span>
				<span>Searching optimal weights…</span>
			</div>
		{/if}
	</div>

	<div class="rounded-lg border border-purple-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-purple-700 uppercase">
			Slowest Custom Solution
		</div>
		{#if limitingCell}
			<p class="mt-2">
				Worst-case among active rules:
				<span class="font-semibold">{limitingCell.limitingRuleId}</span>
			</p>
			<p class="mt-1 font-mono text-base text-gray-800">{limitingCell.maxBase}<sup>n</sup></p>
		{:else}
			<p class="mt-2 text-gray-500">Enable at least one rule with a valid scalar recurrence.</p>
		{/if}
		{#if unresolvedSituations.length}
			<div class="mt-3 space-y-1 text-xs text-amber-700">
				<p class="font-semibold tracking-wide uppercase">
					Situations without a decreasing rule for these weights:
				</p>
				<ul class="list-disc space-y-1 pl-5">
					{#each unresolvedSituations as situationId (situationId)}
						<li>Situation {situationId}</li>
					{/each}
				</ul>
			</div>
		{/if}
	</div>

	<div class="rounded-lg border border-amber-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-amber-700 uppercase">Weight Explorer</div>
		<p class="mt-2">
			This plot plots the base b of the running time O(b^n) as a function of w₂. Hover to see the
			branching rule that limits the running time.
		</p>
		<div class="mt-4 space-y-3">
			<div class="relative">
				<canvas
					bind:this={canvasEl}
					class="mx-auto w-full overflow-hidden rounded border bg-white"
					onmousemove={handleCanvasHover}
					onmouseleave={() => {
						pointerActive = false
						applyAutoHover()
					}}
					aria-label="Weight grid heatmap"></canvas>
				<canvas
					bind:this={overlayCanvasEl}
					class="pointer-events-none absolute inset-0 mx-auto w-full overflow-hidden rounded border border-transparent"
					aria-hidden="true"></canvas>
			</div>
			<div class="rounded-lg border border-gray-200 bg-gray-50 p-3 text-xs text-gray-800">
				{#if hoveredCell}
					<div class="flex items-start gap-2">
						Limiting rule: <span
							class="mt-0.5 h-3.5 w-3.5 rounded-sm"
							style={`background-color: ${ruleColorPalette[0]};`}
							aria-hidden="true"></span>
						<div class="space-y-1">
							<div class="text-sm font-semibold">
								{hoveredCell.limitingRuleId ?? "Invalid weights"}
							</div>
							<div class="font-mono text-sm text-gray-600">
								w4={formatWeight(hoveredCell.w.w4)}, w₃={formatWeight(hoveredCell.w.w3)}, w₂={formatWeight(
									hoveredCell.w.w2
								)}{#if hoveredCell}, {hoveredCell.maxBase}<sup>n</sup>
								{:else}
									<span class="mt-2 text-sm text-red-600"
										>Weights do not decrease every branch.</span>
								{/if}
							</div>
						</div>
					</div>
					{#if hoveredRule}
						<div class="flex flex-row gap-4">
							<div class="mt-3 space-y-1">
								<div class="text-sm font-semibold text-gray-600">Local situation</div>
								<div class="mx-auto w-fit rounded border bg-white p-2">
									<GraphView graph={hoveredRule.before} scale={0.55} />
								</div>
							</div>
							{#if hoveredRule}
								<div class="mt-3 space-y-2">
									<div class="text-sm font-semibold text-gray-600">Branches</div>
									<div class="flex flex-col flex-wrap gap-3">
										{#each hoveredRule.branches as branch (branch.assignments)}
											<div>{describeAssignments(branch.assignments)}</div>
										{/each}
									</div>
								</div>
							{/if}
						</div>
					{/if}
				{:else}
					<p class="text-xs text-gray-500">Hover a cell to see its limiting rule and recurrence.</p>
				{/if}
			</div>
			<div
				class="flex items-center justify-between text-[10px] font-semibold tracking-wide text-gray-500 uppercase">
				<span>Base increases ↑</span>
				<span>w₂ increases →</span>
			</div>
		</div>
		{#if isWeightSearchRunning}
			<p class="mt-3 text-xs text-amber-600">Filling grid with fresh evaluations…</p>
		{/if}
	</div>

	<section class="space-y-6 rounded-xl border border-gray-300 bg-white p-6">
		<header class="space-y-2">
			<h2 class="text-xl font-semibold">Canonical situations</h2>
			<p class="text-gray-600">
				Showing {targetSituations.length} situations filtered by scope and palette. Each card lists the
				rules available for that situation.
			</p>
		</header>

		<div class="grid gap-6 md:grid-cols-2">
			{#each targetSituations as s (s.situationId)}
				{@const rulesForSituation =
					rulesBySituation.get(s.situationId) ?? AUTOGENERATED_RULES[s.situationId] ?? []}
				<div class="space-y-4 rounded-lg border bg-gray-50 p-4">
					<div class="flex items-start justify-between gap-3">
						<div class="space-y-1">
							<div class="font-semibold tracking-wide text-gray-800 uppercase">
								Situation {s.situationId}
							</div>
						</div>
					</div>

					<div class="w-fit rounded border border-dotted bg-white p-2">
						<GraphView graph={s.canon ?? s} scale={0.6} />
					</div>

					<div class="space-y-3">
						{#if rulesForSituation.length === 0}
							<p class="text-xs text-gray-500">No rules available for this situation.</p>
						{:else}
							{#each rulesForSituation as rule (rule.ruleId)}
								{@const solved = generatedGetRuleSolution(rule)}
								<div
									class="space-y-2 rounded border border-dashed bg-white p-3 text-sm text-gray-800">
									<div
										class="flex flex-wrap items-baseline gap-2 text-sm font-semibold tracking-wide text-gray-800">
										<span class="uppercase">Rule {rule.ruleId}:</span>
										<div class="flex flex-wrap items-center gap-2">
											{#each rule.branches as branch, idx (branch.assignments)}
												{#if idx > 0}
													<span class="text-gray-400">|</span>
												{/if}
												<span>{describeAssignments(branch.assignments)}</span>
											{/each}
										</div>
									</div>
									<div class="text-gray-900">{rule.recurrenceDisplay}</div>
									<div class="flex flex-wrap items-baseline gap-2">
										<span>Solution:</span>
										<span>
											{#if solved?.weighted}
												{#await solved.solution}
													<span class="text-gray-500">Computing…</span>
												{:then solution}
													{#if solution?.ok && !solution?.divergent}
														{formatAsymptotics(solution.root)}
													{:else if solution?.ok}
														divergent
													{:else}
														<span class="text-red-600">{solution?.error ?? "Solver error"}</span>
													{/if}
												{:catch error}
													<span class="text-red-600"
														>{error instanceof Error ? error.message : String(error)}</span>
												{/await}
											{:else}
												<span class="text-red-600"
													>Provide coefficients that decrease all branches.</span>
											{/if}
										</span>
									</div>
								</div>
							{/each}
						{/if}
					</div>
				</div>
			{/each}
		</div>
	</section>
</div>
