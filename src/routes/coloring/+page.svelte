<script lang="ts">
	import { onDestroy } from "svelte"
	import { browser } from "$app/environment"
	import { autogenerateRules } from "$lib/coloring/3coloring-rules"
	import type { Color, Graph } from "$lib/coloring/graph-utils"
	import {
		degreeFeatureProvider,
		FeatureDefinition,
		Measure,
		type Feature
	} from "$lib/coloring/measure"
	import {
		analyzeRule,
		buildRecurrenceStrings,
		describeAssignments,
		type BranchingRuleWithAnalysis
	} from "$lib/coloring/rule-engine"
	import { enumerateStarSignatures, parseStarGraph } from "$lib/coloring/star-graph-canonization"
	import BasicSubscripts from "$lib/components/BasicSubscripts.svelte"
	import GraphView from "$lib/components/GraphView.svelte"
	import { formatAsymptotics, formatNumber } from "$lib/root-finding"
	import {
		buildRecurrenceSolutionsForWeights,
		buildWeightedRecurrencesForWeights
	} from "./weight-grid-shared"
	import type { GridWorkerInput, GridWorkerMessage } from "./worker"

	type ColorListSizes = "size234" | "size23" | "size2"
	type ColorPalette = "1234" | "123"

	/**
	 * Memoized list of canonical situations (computed asynchronously for progress reporting).
	 */
	const ALL_LOCAL_SITUATIONS: { canon: Graph; situationId: number; signature: string }[] = []
	const AUTOGENERATED_RULES: BranchingRuleWithAnalysis[][] = []
	let localSituationsStatus = $state({
		loading: true,
		computed: 0,
		success: 0,
		elapsedMs: 0
	})

	const colorListSizeOptions: Array<{
		key: ColorListSizes
		label: string
		description: string
		listSizes?: number[]
	}> = [
		{
			key: "size234",
			label: "Lists of size 2, 3, or 4",
			description: "Enumerate every canonical neighborhood.",
			listSizes: [2, 3, 4]
		},
		{
			key: "size23",
			label: "Lists of size 2 or 3",
			description: "Keep situations where every node has 2 or 3 colors.",
			listSizes: [2, 3]
		},
		{
			key: "size2",
			label: "Lists of size 2",
			description: "Keep situations where every node has 2 colors.",
			listSizes: [2]
		}
	]

	const colorPaletteOptions: Array<{
		key: ColorPalette
		label: string
		description: string
		colors: readonly number[]
	}> = [
		{
			key: "1234",
			label: "List 4-Coloring",
			description: "Color Palette = {1,2,3,4}",
			colors: [1, 2, 3, 4]
		},
		{
			key: "123",
			label: "List 3-Coloring",
			description: "Color Palette = {1,2,3}",
			colors: [1, 2, 3]
		}
	]

	const formatMillis = (ms: number) => {
		if (!Number.isFinite(ms)) return "-"
		if (ms < 1000) return `${ms.toFixed(1)} ms`
		return `${(ms / 1000).toFixed(2)} s`
	}

	const computeSituations = async () => {
		if (!browser) return
		localSituationsStatus.loading = true
		localSituationsStatus.computed = 0
		localSituationsStatus.success = 0
		localSituationsStatus.elapsedMs = 0

		const start = performance.now()
		const yieldToUI = () =>
			new Promise<void>(resolve => {
				if (typeof requestAnimationFrame === "function") requestAnimationFrame(() => resolve())
				else setTimeout(resolve, 0)
			})
		let counter = 0
		function* generator() {
			for (let centerListSize = 2; centerListSize <= 4; centerListSize++) {
				for (let leafListSize = centerListSize; leafListSize <= 4; leafListSize++) {
					for (let degree = 3; degree <= 7; degree++) {
						for (let halfedges = 2; halfedges <= 7; halfedges++) {
							if (centerListSize === leafListSize && degree < halfedges + 1) continue
							yield* enumerateStarSignatures(degree, halfedges, centerListSize, leafListSize)
						}
					}
				}
			}
		}
		for (const signature of generator()) {
			const G = parseStarGraph(signature)
			const situation = { canon: G, situationId: counter, signature }
			ALL_LOCAL_SITUATIONS.push(situation)
			AUTOGENERATED_RULES.push(
				autogenerateRules(situation).map(x =>
					analyzeRule(
						x,
						degreeFeatureProvider.computeFeatureVector,
						degreeFeatureProvider.subtractFeatureVectors
					)
				)
			)
			counter += 1
			if (counter % 100 === 0) {
				localSituationsStatus.computed = counter
				await yieldToUI()
			}
		}
		localSituationsStatus.success = ALL_LOCAL_SITUATIONS.length
		localSituationsStatus.elapsedMs = performance.now() - start
		localSituationsStatus.loading = false
	}
	let selectedColorListSize = $state<ColorListSizes>("size23")
	let selectedPalette = $state<ColorPalette>("123")

	const fixedPartialMeasure = $derived.by(() => {
		const result: Partial<Record<Feature, number>> = {}
		let listSizeUpTo = 4
		if (selectedPalette === "1234") {
			listSizeUpTo = 4
		} else if (selectedPalette === "123") {
			listSizeUpTo = 3
		}
		if (selectedColorListSize === "size23") {
			listSizeUpTo = 3
		} else if (selectedColorListSize === "size2") {
			listSizeUpTo = 2
		}
		for (const f of degreeFeatureProvider.features) {
			const def = FeatureDefinition[f]
			if (def.requiresListSize > listSizeUpTo) result[f] = 0
			if (def.requiresListSize === listSizeUpTo && def.normalizer) result[f] = 1
		}
		return result
	})

	const fixedPartialMeasureEntries = $derived(Object.entries(fixedPartialMeasure))

	const allowedColors = $derived(
		colorPaletteOptions.find(option => option.key === selectedPalette)?.colors ?? [1, 2, 3, 4]
	)

	const allowedSizes = $derived(
		colorListSizeOptions.find(option => option.key === selectedColorListSize)?.listSizes
	)

	const size234Disabled = $derived(selectedPalette === "123")

	function matchesColorPalette(G: Graph, allowedColors?: readonly Color[]): boolean {
		if (allowedColors === undefined) return true
		for (const n of G.nodes) {
			for (const c of n.colors) {
				if (!allowedColors.includes(c)) return false
			}
		}
		return true
	}

	function matchesColorListSizes(G: Graph, allowedSizes?: readonly number[]): boolean {
		if (allowedSizes === undefined) return true
		for (const n of G.nodes) {
			if (!allowedSizes.includes(n.colors.length)) return false
		}
		return true
	}

	const filteredLocalSituations = $derived(
		localSituationsStatus.loading
			? []
			: ALL_LOCAL_SITUATIONS.filter(x => matchesColorPalette(x.canon, allowedColors))
					.filter(x => matchesColorListSizes(x.canon, allowedSizes))
					.map(x => x.situationId)
	)
	const displaySituations = $derived([...filteredLocalSituations.slice(0, 500)])
	const filteredRules = $derived(
		localSituationsStatus.loading ? [] : filteredLocalSituations.map(s => AUTOGENERATED_RULES[s])
	)

	const formatPercent = (num: number) => `${num.toFixed(1)}%`

	let userWeights = $state(new Measure(1).coefficients)
	let isWeightSearchRunning = $state(false)
	let weightSearchProgress = $state({ mode: "", percent: 0 })
	let lastBestWeights = $state<Measure | null>(null)
	let lastBestBase = $state<number | null>(null)
	let currentSearchBounds = $state<null | {
		min: Partial<Record<Feature, number>>
		max: Partial<Record<Feature, number>>
	}>(null)

	const generatedWeightedRecurrences = $derived.by(() =>
		localSituationsStatus.loading
			? []
			: AUTOGENERATED_RULES.map(group =>
					buildWeightedRecurrencesForWeights(new Measure(userWeights), group)
				)
	)
	const generatedRecurrenceSolutions = $derived.by(() =>
		generatedWeightedRecurrences.map(group =>
			buildRecurrenceSolutionsForWeights(new Measure(userWeights), group)
		)
	)

	const sortedDisplaySituations = $derived.by(() => {
		const sol = generatedRecurrenceSolutions.map(y =>
			y.map(x => (x?.ok ? (x.divergent ? Infinity : Object.values(x.root)[0]) : 0))
		)
		return displaySituations.toSorted((a, b) => Math.min(...sol[b]) - Math.min(...sol[a]))
	})

	const limitingSituationId = $derived(sortedDisplaySituations[0])

	let worker: Worker | null = null
	let searchVersion = 0
	const stopWorker = () => {
		searchVersion += 1
		worker?.terminate()
		worker = null
		isWeightSearchRunning = false
	}

	const buildDefaultBounds = () => {
		const min: Partial<Record<Feature, number>> = {}
		const max: Partial<Record<Feature, number>> = {}
		for (const f of degreeFeatureProvider.features) {
			const fixed = fixedPartialMeasure[f]
			if (fixed !== undefined) {
				min[f] = fixed
				max[f] = fixed
			} else {
				min[f] = 0
				max[f] = 1
			}
		}
		return { min, max }
	}

	const startOptimization = (bounds?: {
		min: Partial<Record<Feature, number>>
		max: Partial<Record<Feature, number>>
	}) => {
		if (!browser) return
		if (filteredRules.length === 0) return
		stopWorker()
		const version = ++searchVersion
		isWeightSearchRunning = true
		currentSearchBounds = bounds ?? buildDefaultBounds()
		lastBestWeights = null
		lastBestBase = null
		let best: { weights: Measure | null; base: number } = { weights: null, base: Infinity }
		weightSearchProgress = {
			mode: "Opimizing",
			percent: 0
		}
		worker = new Worker(new URL("./worker.ts", import.meta.url), { type: "module" })
		worker.onmessage = (event: MessageEvent<GridWorkerMessage>) => {
			if (version !== searchVersion) return
			const message = event.data
			if (message.type === "progress") {
				weightSearchProgress.percent = message.percent
			} else if (message.type === "currentBest") {
				const { x, value } = message
				const w = new Measure(
					Object.fromEntries(degreeFeatureProvider.features.map((f, i) => [f, x[i]])) as Record<
						Feature,
						number
					>
				)
				if (best.weights === null || value < best.base) {
					best = { weights: w, base: value }
					userWeights = w.coefficients
					lastBestWeights = best.weights
					lastBestBase = best.base
				}
			} else if (message.type === "done") {
				if (best.weights) {
					lastBestWeights = best.weights
					lastBestBase = best.base
				}
				isWeightSearchRunning = false
			} else if (message.type === "error") {
				console.error(message.message)
				isWeightSearchRunning = false
			}
		}
		worker.onerror = err => {
			if (version !== searchVersion) return
			console.error(err)
			isWeightSearchRunning = false
		}
		const { min: minPartialMeasure, max: maxPartialMeasure } =
			currentSearchBounds ?? buildDefaultBounds()
		const payload: GridWorkerInput = {
			type: "start",
			ruleGroups: [...filteredRules],
			minPartialMeasure: { ...minPartialMeasure },
			maxPartialMeasure: { ...maxPartialMeasure }
		}
		worker.postMessage(payload)
	}

	const handleStartSearch = () => {
		if (isWeightSearchRunning) return
		startOptimization()
	}

	const generatedGetRuleSolution = (rule: BranchingRuleWithAnalysis) => {
		const situationIdx = rule.situationId
		const ruleIdx = rule.situationRuleId
		if (
			situationIdx === undefined ||
			situationIdx === null ||
			situationIdx < 0 ||
			!Number.isInteger(situationIdx) ||
			ruleIdx === undefined ||
			ruleIdx === null ||
			ruleIdx < 0
		)
			return null
		const weighted = generatedWeightedRecurrences[situationIdx]?.[ruleIdx] ?? null
		const solution = generatedRecurrenceSolutions[situationIdx]?.[ruleIdx] ?? null
		return { weighted, solution }
	}

	onDestroy(() => {
		worker?.terminate()
		worker = null
	})

	$effect(() => {
		if (browser) queueMicrotask(computeSituations)
		else computeSituations()
	})

	$effect(() => {
		if (size234Disabled && selectedColorListSize === "size234") {
			selectedColorListSize = "size23"
		}
	})

	$effect(() => {
		stopWorker()
		lastBestWeights = null
		lastBestBase = null
		weightSearchProgress = { mode: "", percent: 0 }
		currentSearchBounds = null
	})
</script>

<div class="mx-auto max-w-6xl space-y-12 sm:p-8">
	<h1 class="text-3xl font-bold">Branching Rules for List 3‑Coloring</h1>

	<p class="text-gray-700">
		Each rule below illustrates a local structure in a list-coloring instance, its branching
		options, and the resulting recurrence on the measures we track. After each rule you can inspect
		the recurrence, a weighted scalar reduction (when available), and the asymptotic solution
		produced by the recurrence solver.
	</p>
	<div class="rounded-lg border border-sky-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-sky-700 uppercase">Tasks</div>
		<div class="mt-3 space-y-3">
			<div class="flex items-start gap-3">
				<span
					class={localSituationsStatus.loading
						? "mt-0.5 inline-flex h-4 w-4 animate-spin rounded-full border-2 border-sky-400 border-t-transparent"
						: "mt-0.5 inline-flex h-4 w-4 rounded-full bg-emerald-500"}
					aria-hidden="true"></span>
				<div class="space-y-0.5">
					<div class="font-semibold">Computing canonical local situations</div>
					<div class="text-xs text-gray-600">
						{#if localSituationsStatus.loading}
							Computed {localSituationsStatus.computed} so far…
						{:else}
							Found {localSituationsStatus.success} situations in
							{formatMillis(localSituationsStatus.elapsedMs)}
						{/if}
					</div>
				</div>
			</div>
			<div class="flex items-start gap-3">
				{#if isWeightSearchRunning || filteredRules.length === 0}
					<span
						class="mt-0.5 inline-flex h-4 w-4 animate-spin rounded-full border-2 border-amber-400 border-t-transparent"
						aria-hidden="true"></span>
				{:else}
					<span class="mt-0.5 inline-flex h-4 w-4 rounded-full bg-emerald-500" aria-hidden="true"
					></span>
				{/if}
				<div class="space-y-0.5">
					<div class="font-semibold">Start optimization</div>
					<div class="text-xs text-gray-600">
						{#if isWeightSearchRunning}
							{weightSearchProgress.mode}
							— {formatPercent((weightSearchProgress.percent ?? 0) * 100)} complete
						{:else if filteredRules.length === 0}
							Waiting for situations to generate…
						{:else if lastBestWeights}
							Completed latest optimization.
						{:else}
							Optimization not started.
						{/if}
					</div>
					<div class="pt-1">
						<button
							class="rounded bg-amber-600 px-3 py-2 text-xs font-semibold text-white uppercase shadow hover:bg-amber-700 disabled:cursor-not-allowed disabled:bg-amber-300"
							onclick={handleStartSearch}
							disabled={isWeightSearchRunning ||
								filteredRules.length === 0 ||
								localSituationsStatus.loading}>
							Start search
						</button>
						<p class="mt-2 max-w-xl text-xs text-gray-600">
							Heuristically find a measure that minimizes the base b in O(b<sup>μ</sup>) that upper
							bounds all recurrence relations; the best measure and limiting situation are
							summarized here.
						</p>
						{#if lastBestWeights && lastBestBase !== null}
							<div
								class="mt-2 rounded border border-amber-100 bg-amber-50 px-3 py-2 text-xs text-amber-900">
								<div class="font-semibold">Best so far</div>
								<div class="mt-1 flex flex-col gap-1">
									<div>
										Measure:
										<span class="font-mono text-amber-800">
											<BasicSubscripts
												raw={`μ = ${new Measure(lastBestWeights.coefficients).toString()}`} />
										</span>
									</div>
									<div>Base: O({formatNumber(lastBestBase)}<sup>μ</sup>)</div>
									{#if limitingSituationId !== null}
										<div>Limiting situation: #{limitingSituationId}</div>
										{#if !localSituationsStatus.loading && ALL_LOCAL_SITUATIONS[limitingSituationId]}
											<div class="mt-2 w-fit rounded border border-dotted bg-white p-2">
												<GraphView
													graph={ALL_LOCAL_SITUATIONS[limitingSituationId].canon}
													scale={0.6} />
											</div>
										{/if}
									{/if}
								</div>
							</div>
						{/if}
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="space-y-4 rounded-lg border border-indigo-200 bg-white p-4 text-sm text-gray-800">
		<div class="space-y-2">
			<div class="text-xs font-semibold tracking-wide text-indigo-700 uppercase">
				Choose the problem
			</div>
			<div class="grid gap-3 md:grid-cols-3">
				{#each colorPaletteOptions as option (option.key)}
					<label
						class="flex cursor-pointer items-start gap-3 rounded-md border border-gray-200 bg-gray-50 p-3 transition hover:border-indigo-400">
						<input
							type="radio"
							class="mt-1 h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
							name="color-palette"
							value={option.key}
							bind:group={selectedPalette} />
						<div class="space-y-1">
							<div class="text-sm font-semibold text-gray-800">{option.label}</div>
							<p class="text-xs text-gray-600">{option.description}</p>
						</div>
					</label>
				{/each}
			</div>
		</div>
		<div class="space-y-2">
			<div class="text-xs font-semibold tracking-wide text-indigo-700 uppercase">
				Restricted list size
			</div>
			<div class="grid gap-3 md:grid-cols-3">
				{#each colorListSizeOptions as option (option.key)}
					<label
						class={`flex items-start gap-3 rounded-md border border-gray-200 bg-gray-50 p-3 transition ${
							option.key === "size234" && size234Disabled
								? "cursor-not-allowed opacity-60"
								: "cursor-pointer hover:border-indigo-400"
						}`}
						aria-disabled={option.key === "size234" && size234Disabled}>
						<input
							type="radio"
							class="mt-1 h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
							name="situation-variant"
							value={option.key}
							bind:group={selectedColorListSize}
							disabled={option.key === "size234" && size234Disabled} />
						<div class="space-y-1">
							<div class="text-sm font-semibold text-gray-800">{option.label}</div>
							<p class="text-xs text-gray-600">{option.description}</p>
						</div>
					</label>
				{/each}
			</div>
			{#if fixedPartialMeasureEntries.length}
				<div class="rounded-md border border-indigo-100 bg-indigo-50/60 p-3 text-xs text-gray-700">
					<div class="font-semibold text-indigo-800">Fixed coefficients</div>
					<ul class="mt-2 space-y-1">
						{#each fixedPartialMeasureEntries as [feature, value] (feature)}
							<li class="flex items-center gap-2 font-mono">
								<BasicSubscripts raw={"coefficient." + feature} />
								<span class="text-gray-500">=</span>
								<span class="font-mono text-gray-800">{value}</span>
							</li>
						{/each}
					</ul>
				</div>
			{/if}
		</div>
	</div>

	<div class="rounded-lg border border-gray-300 bg-gray-50 p-4 text-sm text-gray-800">
		<div class="font-semibold tracking-wide text-gray-600 uppercase">Legend</div>
		<ul class="mt-2 list-disc space-y-1 pl-5">
			{#each degreeFeatureProvider.features as f (f)}
				<li>
					<span class="font-mono"><BasicSubscripts raw={f} /></span> — {degreeFeatureProvider.describeFeature(
						f
					)}
				</li>
			{/each}
		</ul>
	</div>

	<div class="rounded-lg border border-emerald-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-emerald-700 uppercase">Custom Measure</div>
		<p class="mt-2">
			Set the coefficients to define the scalar measure <span class="font-mono">μ</span> that the solver
			will use for every rule.
		</p>
		<div class="mt-4 grid gap-4 md:grid-cols-3">
			{#each degreeFeatureProvider.features as f (f)}
				<label class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600">
					<span><span class="uppercase">Coefficient of</span> <BasicSubscripts raw={f} /></span>
					<input
						type="number"
						min="0"
						step="0.1"
						class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
						bind:value={userWeights[f]} />
				</label>
			{/each}
		</div>
		<p class="mt-3 text-xs text-gray-500">
			Current measure:
			<span class="font-mono"
				>μ = <BasicSubscripts raw={new Measure(userWeights).toString()} /></span>
		</p>
		{#if isWeightSearchRunning}
			<div class="mt-3 flex items-center gap-2 text-xs font-semibold text-emerald-700">
				<span
					class="inline-flex h-4 w-4 animate-spin rounded-full border-2 border-emerald-400 border-t-transparent"
					aria-hidden="true"></span>
				<span>Searching optimal weights…</span>
			</div>
		{/if}
	</div>

	<section class="space-y-6 rounded-xl border border-gray-300 bg-white p-6">
		<header class="space-y-2">
			<h2 class="text-xl font-semibold">Canonical situations</h2>
			<p class="text-gray-600">
				Showing {filteredLocalSituations.length} situations filtered by scope and palette. Each card lists
				the rules available for that situation.
			</p>
		</header>

		<div class="grid gap-6 md:grid-cols-2">
			{#await sortedDisplaySituations}
				Waiting
			{:then x}
				{#each x as s (ALL_LOCAL_SITUATIONS[s].signature)}
					{@const rulesForSituation = AUTOGENERATED_RULES[s] ?? []}
					<div class="space-y-4 rounded-lg border bg-gray-50 p-4">
						<div class="flex items-start justify-between gap-3">
							<div class="space-y-1">
								<div class="font-semibold tracking-wide text-gray-800 uppercase">
									Situation #{s}
								</div>
								<div class="font-mono text-gray-600">
									{ALL_LOCAL_SITUATIONS[s].signature}
								</div>
							</div>
						</div>

						<div class="w-fit rounded border border-dotted bg-white p-2">
							<GraphView graph={ALL_LOCAL_SITUATIONS[s].canon} scale={0.6} />
						</div>

						<div class="space-y-3">
							{#if rulesForSituation.length === 0}
								<p class="text-xs text-gray-500">No rules available for this situation.</p>
							{:else}
								{#each rulesForSituation as rule (rule.situationRuleId)}
									{@const solved = generatedGetRuleSolution(rule)}
									<div
										class="space-y-2 rounded border border-dashed bg-white p-3 text-sm text-gray-800">
										<span class="font-semibold tracking-wide uppercase"
											>Rule {rule.situationRuleId}:</span>
										<div class="flex flex-wrap items-baseline gap-2 text-sm">
											<div class="grid grid-cols-[auto_auto_1fr] gap-2">
												{#each rule.branches as branch, idx (branch.assignments)}
													<div>{describeAssignments(branch.assignments)}</div>
													<div class="text-gray-400">|</div>
													<BasicSubscripts
														raw={buildRecurrenceStrings(
															[rule.branchDetails[idx].featuresDelta],
															true
														)} />
												{/each}
											</div>
										</div>
										{#if solved?.weighted}
											<div class="space-y-2">
												<div>{solved.weighted.equation}</div>
												<div>
													<span>Solution:</span>
													<span>
														{#if solved.weighted.decreasing}
															{#await solved.solution}
																<span class="text-gray-500">Computing…</span>
															{:then solution}
																{#if solution?.ok && !solution?.divergent}
																	{formatAsymptotics(solution.root)}
																{:else if solution?.ok}
																	Divergent
																{:else}
																	<span class="text-red-600"
																		>Solver error: {solution?.error ?? "unknown"}</span>
																{/if}
															{:catch error}
																<span class="text-red-600"
																	>Unknown error: {error instanceof Error
																		? error.message
																		: String(error)}</span>
															{/await}
														{:else}
															Divergent
														{/if}
													</span>
												</div>
											</div>
										{/if}
									</div>
								{/each}
							{/if}
						</div>
					</div>
				{/each}
			{/await}
		</div>
		<!-- <pre>
{localSituationsStatus.loading ? "Getting ready..." : JSON.stringify(ALL_LOCAL_SITUATIONS)}
		</pre> -->
	</section>
</div>
