<script lang="ts">
	import { onDestroy, onMount } from "svelte"
	import { SvelteMap } from "svelte/reactivity"
	import { browser } from "$app/environment"
	import { autogeneratedRules } from "$lib/coloring/3coloring-rules"
	import { buildMissingRuleSnippets } from "$lib/coloring/canon"
	import {
		analyzeRules,
		describeAssignments,
		testBranchingRuleExhaustiveness,
		type WeightVector
	} from "$lib/coloring/rule-engine"
	import GraphView from "$lib/components/GraphView.svelte"
	import type {
		GridWorkerCellMessage,
		GridWorkerDoneMessage,
		GridWorkerInput,
		GridWorkerMessage
	} from "./weight-grid"
	import {
		buildInitialWeightGrid,
		buildRecurrenceSolutionsForWeights,
		buildRuleIndexMap,
		buildWeightedRecurrencesForWeights,
		extractGrowthBase,
		formatWeight,
		GRID_AXIS_COUNT,
		weightIndex,
		type WeightGridCell
	} from "./weight-grid-shared"

	const ruleGroups = autogeneratedRules
	const allRules = ruleGroups.flat()
	const ruleMap = new Map(allRules.map(rule => [rule.name, rule]))
	const ruleAnalyses = analyzeRules(allRules)
	const ruleIndexMap = buildRuleIndexMap(allRules)
	const exhaustivenessReport = $derived(testBranchingRuleExhaustiveness(allRules))
	const missingRuleSnippets = $derived(buildMissingRuleSnippets(exhaustivenessReport))

	let userWeights = $state<WeightVector>({ w3: 1, w2: 0.6241 })
	let isWeightSearchRunning = $state(false)
	let weightGrid = $state<WeightGridCell[]>(buildInitialWeightGrid())
	let worker: Worker | null = null

	let canvasEl: HTMLCanvasElement | null = null
	let ctx: CanvasRenderingContext2D | null = null
	let imageData: ImageData | null = null
	let canvasDirty = false
	const cellCache = new SvelteMap<number, WeightGridCell>()
	let hoveredCell = $state<WeightGridCell | null>(null)
	const PENDING_RGB: [number, number, number] = [229, 231, 235]
	let resizeListener: (() => void) | null = null

	const hexToRgb = (hex: string): [number, number, number] => {
		const normalized = hex.replace("#", "")
		const num = parseInt(normalized, 16)
		return [(num >> 16) & 255, (num >> 8) & 255, num & 255]
	}

	const clearCanvasBuffer = () => {
		if (!imageData) return
		for (let i = 0; i < imageData.data.length; i += 4) {
			imageData.data[i] = PENDING_RGB[0]
			imageData.data[i + 1] = PENDING_RGB[1]
			imageData.data[i + 2] = PENDING_RGB[2]
			imageData.data[i + 3] = 255
		}
		canvasDirty = true
	}

	const flushCanvas = () => {
		if (ctx && imageData && canvasDirty) {
			ctx.putImageData(imageData, 0, 0)
			canvasDirty = false
		}
		requestAnimationFrame(flushCanvas)
	}

	const initCanvas = () => {
		if (!canvasEl) return
		ctx = canvasEl.getContext("2d")
		if (!ctx) return
		ctx.imageSmoothingEnabled = false
		canvasEl.width = GRID_AXIS_COUNT
		canvasEl.height = GRID_AXIS_COUNT
		canvasEl.style.imageRendering = "pixelated"
		const resize = () => {
			const parentWidth =
				canvasEl?.parentElement?.clientWidth ?? canvasEl?.clientWidth ?? GRID_AXIS_COUNT
			const scale = Math.max(1, Math.floor(parentWidth / GRID_AXIS_COUNT))
			canvasEl!.style.width = `${GRID_AXIS_COUNT * scale}px`
			canvasEl!.style.height = `${GRID_AXIS_COUNT * scale}px`
		}
		resize()
		resizeListener = () => resize()
		window.addEventListener("resize", resizeListener)
		imageData = ctx.createImageData(GRID_AXIS_COUNT, GRID_AXIS_COUNT)
		clearCanvasBuffer()
		flushCanvas()
	}

	const writeCellToBuffer = (index: number, cell: WeightGridCell) => {
		if (!imageData) return
		const x = index % GRID_AXIS_COUNT
		const y = Math.floor(index / GRID_AXIS_COUNT)
		const offset = (y * GRID_AXIS_COUNT + x) * 4
		const [r, g, b] = hexToRgb(cell.color)
		imageData.data[offset] = r
		imageData.data[offset + 1] = g
		imageData.data[offset + 2] = b
		imageData.data[offset + 3] = 255
		canvasDirty = true
	}

	const handleCanvasHover = (event: MouseEvent) => {
		if (!canvasEl) return
		const rect = canvasEl.getBoundingClientRect()
		const scale = rect.width / GRID_AXIS_COUNT
		const x = Math.floor((event.clientX - rect.left) / scale)
		const y = Math.floor((event.clientY - rect.top) / scale)
		if (x < 0 || y < 0 || x >= GRID_AXIS_COUNT || y >= GRID_AXIS_COUNT) {
			hoveredCell = null
			return
		}
		const idx = y * GRID_AXIS_COUNT + x
		const cell = cellCache.get(idx) ?? weightGrid[idx]
		hoveredCell = cell ?? null
	}

	const weightedRecurrences = $derived(
		buildWeightedRecurrencesForWeights(userWeights, ruleAnalyses)
	)

	const recurrenceSolutions = $derived(
		buildRecurrenceSolutionsForWeights(userWeights, weightedRecurrences)
	)

	type RuleCompatibilityIssue = { name: string; reason: string }
	const incompatibleRules = $derived(
		allRules
			.map(rule => {
				const idx = ruleIndexMap.get(rule.name)
				if (idx === undefined) return null
				const weighted = weightedRecurrences[idx]
				const solutionPromise = recurrenceSolutions[idx]
				if (weighted && solutionPromise) return null
				return {
					name: rule.name,
					reason: !weighted
						? "Selected weights do not decrease every branch."
						: "Recurrence solver unavailable for these weights."
				}
			})
			.filter((issue): issue is RuleCompatibilityIssue => issue !== null)
	)

	const limitingCell = $derived.by(() => {
		if (isWeightSearchRunning) return null
		const i = weightIndex(userWeights.w3)
		const j = weightIndex(userWeights.w2)
		const idx = i * GRID_AXIS_COUNT + j
		return weightGrid[idx] ?? null
	})

	const hoveredRule = $derived.by(() => {
		if (!hoveredCell || !hoveredCell.limitingRule) return null
		return ruleMap.get(hoveredCell.limitingRule) ?? null
	})

	const hoveredAnalysis = $derived.by(() => {
		if (!hoveredRule) return null
		const idx = ruleIndexMap.get(hoveredRule.name)
		return idx === undefined ? null : ruleAnalyses[idx]
	})

	onMount(() => {
		if (!browser) return
		if (isWeightSearchRunning) return
		isWeightSearchRunning = true
		weightGrid = buildInitialWeightGrid()
		cellCache.clear()
		clearCanvasBuffer()
		initCanvas()
		let best: { weights: WeightVector | null; base: number } = { weights: null, base: Infinity }
		worker = new Worker(new URL("./weight-grid.ts", import.meta.url), { type: "module" })
		worker.onmessage = (event: MessageEvent<GridWorkerMessage>) => {
			const message = event.data
			if (message.type === "cell") {
				const { index, cell } = message as GridWorkerCellMessage
				weightGrid[index] = cell
				cellCache.set(index, cell)
				writeCellToBuffer(index, cell)
				const base = cell.solution ? extractGrowthBase(cell.solution) : null
				if (base !== null && (best.weights === null || base < best.base)) {
					best = { weights: { w3: cell.w3, w2: cell.w2 }, base }
				}
			} else if (message.type === "done") {
				const { bestWeights } = message as GridWorkerDoneMessage
				if (bestWeights) userWeights = bestWeights
				isWeightSearchRunning = false
			} else if (message.type === "error") {
				console.error(message.message)
				isWeightSearchRunning = false
			}
		}
		worker.onerror = err => {
			console.error(err)
			isWeightSearchRunning = false
		}
		const activeRuleNames = allRules.map(rule => rule.name)
		const payload: GridWorkerInput = {
			type: "start",
			axisCount: GRID_AXIS_COUNT,
			activeRuleNames
		}
		worker.postMessage(payload)
	})

	onDestroy(() => {
		if (resizeListener) {
			window.removeEventListener("resize", resizeListener)
			resizeListener = null
		}
		worker?.terminate()
		worker = null
	})
</script>

<div class="mx-auto max-w-6xl space-y-12 p-8">
	<h1 class="text-3xl font-bold">Branching Rules for List 3‑Coloring</h1>

	<p class="text-gray-700">
		Each rule below illustrates a local structure in a list-coloring instance, its branching
		options, and the resulting recurrence on the measures we track. After each rule you can inspect
		the recurrence, a weighted scalar reduction (when available), and the asymptotic solution
		produced by the recurrence solver.
	</p>

	<div class="rounded-lg border border-gray-300 bg-gray-50 p-4 text-sm text-gray-800">
		<div class="font-semibold tracking-wide text-gray-600 uppercase">Legend</div>
		<ul class="mt-2 list-disc space-y-1 pl-5">
			<li>
				<span class="font-mono">n₃</span> — number of vertices whose lists still contain three colors
				and whose degree is at least three.
			</li>
			<li>
				<span class="font-mono">n₂</span> — number of vertices with two available colors and degree at
				least three.
			</li>
		</ul>
		(Neighbors of branching vertices are assumed to have degree at least three.)
	</div>

	<div class="rounded-lg border border-emerald-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-emerald-700 uppercase">Custom Measure</div>
		<p class="mt-2">
			Set the coefficients for <span class="font-mono">n₃</span> and
			<span class="font-mono">n₂</span>
			to define the scalar measure <span class="font-mono">n = c₃·n₃ + c₂·n₂</span> that the solver will
			use for every rule.
		</p>
		<div class="mt-4 grid gap-4 md:grid-cols-2">
			<label
				class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600 uppercase">
				<span>Coefficient c₃ (n₃)</span>
				<input
					type="number"
					min="0"
					step="0.1"
					class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
					bind:value={userWeights.w3} />
			</label>
			<label
				class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600 uppercase">
				<span>Coefficient c₂ (n₂)</span>
				<input
					type="number"
					min="0"
					step="0.1"
					class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
					bind:value={userWeights.w2} />
			</label>
		</div>
		<p class="mt-3 text-xs text-gray-500">
			Current measure: <span class="font-mono">n = {userWeights.w3}·n₃ + {userWeights.w2}·n₂</span>
		</p>
		{#if isWeightSearchRunning}
			<div class="mt-3 flex items-center gap-2 text-xs font-semibold text-emerald-700">
				<span
					class="inline-flex h-4 w-4 animate-spin rounded-full border-2 border-emerald-400 border-t-transparent"
					aria-hidden="true"></span>
				<span>Searching optimal weights…</span>
			</div>
		{/if}
	</div>

	<div class="rounded-lg border border-purple-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-purple-700 uppercase">
			Slowest Custom Solution
		</div>
		{#if limitingCell && limitingCell.limitingRule && limitingCell.solution}
			<p class="mt-2">
				Worst-case among active rules:
				<span class="font-semibold">{limitingCell.limitingRule}</span>
			</p>
			<p class="mt-1 font-mono text-base text-gray-800">{limitingCell.solution}</p>
		{:else}
			<p class="mt-2 text-gray-500">Enable at least one rule with a valid scalar recurrence.</p>
		{/if}
		{#if incompatibleRules.length}
			<div class="mt-3 space-y-1 text-xs text-amber-700">
				<p class="font-semibold tracking-wide uppercase">Incompatible measure for:</p>
				<ul class="list-disc space-y-1 pl-5">
					{#each incompatibleRules as issue (issue.name)}
						<li>
							<span class="font-semibold">{issue.name}</span>
							<span class="text-gray-600">— {issue.reason}</span>
						</li>
					{/each}
				</ul>
			</div>
		{/if}
	</div>

	<div class="rounded-lg border border-blue-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-blue-700 uppercase">Coverage Check</div>
		<p class="mt-2">
			Covered {exhaustivenessReport.coveredCount} of {exhaustivenessReport.totalSituations} canonical
			situations.
		</p>
		{#if exhaustivenessReport.exhaustive}
			<p class="mt-1 text-sm font-medium text-green-700">
				All eligible local situations are covered.
			</p>
		{:else}
			<p class="mt-1 text-sm font-medium text-red-700">
				Missing {exhaustivenessReport.missing.length} situations. Showing up to six examples below.
			</p>
			<div class="mt-4 grid gap-4 md:grid-cols-2">
				{#each exhaustivenessReport.missing.slice(0, 6) as situation (situation.signature())}
					<div class="space-y-2 rounded-lg border bg-gray-50 p-3">
						<div class="text-xs font-semibold text-gray-500 uppercase">Missing situation</div>
						<GraphView graph={situation} scale={0.6} />
					</div>
				{/each}
			</div>
		{/if}
	</div>

	<div class="rounded-lg border border-amber-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-amber-700 uppercase">
			Weight Grid Explorer
		</div>
		<p class="mt-2">
			Each “pixel” shows the worst-case rule for a weight pair. Hover to see the limiting rule and
			recurrence for that weight choice. Gray cells indicate invalid weights that fail to decrease
			every branch.
		</p>
		<div class="mt-4 space-y-3">
			<div class="relative">
				<canvas
					bind:this={canvasEl}
					class="w-full overflow-hidden rounded border border-gray-200 bg-white"
					onmousemove={handleCanvasHover}
					onmouseleave={() => {
						hoveredCell = null
					}}
					aria-label="Weight grid heatmap"></canvas>
			</div>
			<div class="rounded-lg border border-gray-200 bg-gray-50 p-3 text-xs text-gray-800">
				{#if hoveredCell}
					<div class="flex items-start gap-2">
						<span
							class="mt-0.5 h-3.5 w-3.5 rounded-sm"
							style={`background-color: ${hoveredCell.color};`}
							aria-hidden="true"></span>
						<div class="space-y-1">
							<div class="text-sm font-semibold">
								{hoveredCell.limitingRule ?? "Invalid weights"}
							</div>
							<div class="font-mono text-sm text-gray-600">
								w₃={formatWeight(hoveredCell.w3)}, w₂={formatWeight(
									hoveredCell.w2
								)}{#if hoveredCell.solution}, {hoveredCell.solution}
								{:else}
									<span class="mt-2 text-sm text-red-600"
										>Weights do not decrease every branch.</span>
								{/if}
							</div>
						</div>
					</div>
					{#if hoveredRule}
						<div class="flex flex-row gap-4">
							<div class="mt-3 space-y-1">
								<div class="text-sm font-semibold text-gray-600">Local situation</div>
								<div class="mx-auto w-fit rounded border bg-white p-2">
									<GraphView graph={hoveredRule.before} scale={0.55} />
								</div>
							</div>
							{#if hoveredAnalysis}
								<div class="mt-3 space-y-2">
									<div class="text-sm font-semibold text-gray-600">Branches</div>
									<div class="flex flex-col flex-wrap gap-3">
										{#each hoveredRule.branches as branch, j (branch.assignments)}
											<!-- <div class="min-w-40 flex-1 space-y-1 rounded border bg-white p-2"> -->
											<!-- <div class="text-xs font-semibold text-gray-700"> -->
											<div>{describeAssignments(branch.assignments)}</div>
											<!-- </div> -->
											<!-- <GraphView graph={hoveredAnalysis.branchDetails[j].after} scale={0.2} /> -->
											<!-- </div> -->
										{/each}
									</div>
								</div>
							{/if}
						</div>
					{/if}
				{:else}
					<p class="text-xs text-gray-500">Hover a cell to see its limiting rule and recurrence.</p>
				{/if}
			</div>
			<div
				class="flex items-center justify-between text-[10px] font-semibold tracking-wide text-gray-500 uppercase">
				<span>w₃ increases ↓</span>
				<span>w₂ increases →</span>
			</div>
		</div>
		{#if isWeightSearchRunning}
			<p class="mt-3 text-xs text-amber-600">Filling grid with fresh evaluations…</p>
		{/if}
	</div>

	{#each allRules as rule, i (rule.name)}
		{@const analysis = ruleAnalyses[i]}
		<section class="space-y-8 rounded-xl border border-gray-300 p-6">
			<header class="flex flex-wrap items-start justify-between gap-4">
				<div>
					<h2 class="text-xl font-semibold">{rule.name}</h2>
					<p class="mt-1 text-gray-600">{rule.description}</p>
				</div>
			</header>

			<div class="rounded-lg border border-dashed bg-white p-4 text-sm">
				<div class="text-xs font-semibold tracking-wide text-gray-500 uppercase">Recurrence</div>
				<div class="font-mono text-base">{analysis.recurrenceDisplay}</div>

				<div class="mt-3 text-xs font-semibold tracking-wide text-gray-500 uppercase">
					Scalar Recurrence (custom measure)
				</div>
				{#if weightedRecurrences[i]}
					<div class="font-mono text-base">{weightedRecurrences[i]?.display}</div>
				{:else}
					<div class="text-sm text-red-600">
						The chosen coefficients do not decrease every branch.
					</div>
				{/if}

				<div class="mt-3 text-xs font-semibold tracking-wide text-gray-500 uppercase">Solution</div>
				<div class="font-mono text-base text-gray-800">
					{#if weightedRecurrences[i] && recurrenceSolutions[i]}
						{#await recurrenceSolutions[i]}
							<span class="text-gray-500">Computing…</span>
						{:then solution}
							{solution}
						{:catch error}
							<span class="text-red-600">
								{error instanceof Error ? error.message : String(error)}
							</span>
						{/await}
					{:else}
						<span class="text-red-600">Provide coefficients that decrease all branches.</span>
					{/if}
				</div>
			</div>

			<!-- BEFORE -->
			<div>
				<h3 class="mb-2 font-medium">Before branching</h3>
				<div class="mx-auto w-fit space-y-2 rounded-lg border bg-gray-50 p-4">
					<GraphView graph={rule.before} />
				</div>
			</div>

			<!-- AFTER -->
			<div>
				<h3 class="mb-3 font-medium">After branching</h3>

				<div class="flex flex-wrap gap-6">
					{#each rule.branches as branch, j (branch.assignments)}
						<div class="flex-1 space-y-2 rounded-lg bg-gray-50 p-2 ring ring-amber-300">
							<div class="font-semibold">{describeAssignments(branch.assignments)}</div>
							<GraphView graph={analysis.branchDetails[j].after} scale={0.65} />
						</div>
					{/each}
				</div>
			</div>
		</section>
	{/each}

	{#if missingRuleSnippets.length}
		<section class="space-y-4 rounded-xl border border-gray-300 bg-white p-6">
			<header>
				<h2 class="text-xl font-semibold">Generated rule templates</h2>
				<p class="mt-1 text-gray-600">
					Copy any snippet below into <span class="font-mono">rules</span> to cover the remaining cases.
				</p>
			</header>
			<pre
				class="rounded-lg border bg-gray-50 p-4 font-mono text-xs leading-relaxed whitespace-pre-wrap">
				{missingRuleSnippets.join(",\n")}
			</pre>
		</section>
	{/if}
</div>
