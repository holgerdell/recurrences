<script lang="ts">
	import { onDestroy } from "svelte"
	import { SvelteMap } from "svelte/reactivity"
	import { browser } from "$app/environment"
	import { ALL_LOCAL_SITUATIONS, autogeneratedRules } from "$lib/coloring/3coloring-rules"
	import { buildMissingRuleSnippets } from "$lib/coloring/canon"
	import { analyzeRules, describeAssignments, type WeightVector } from "$lib/coloring/rule-engine"
	import GraphView from "$lib/components/GraphView.svelte"
	import type {
		GridWorkerCellMessage,
		GridWorkerDoneMessage,
		GridWorkerInput,
		GridWorkerMessage
	} from "./weight-grid"
	import {
		buildInitialWeightGrid,
		buildRecurrenceSolutionsForWeights,
		buildRuleIndexMap,
		buildWeightedRecurrencesForWeights,
		extractGrowthBase,
		formatWeight,
		GRID_AXIS_COUNT,
		GRID_SEARCH_STEP,
		weightIndex,
		type WeightGridCell
	} from "./weight-grid-shared"

	type RuleGroup = (typeof autogeneratedRules)[number]
	type SituationVariant = "all" | "size2Only" | "withSize3"

	const variantOptions: Array<{
		key: SituationVariant
		label: string
		description: string
	}> = [
		{
			key: "all",
			label: "All local situations",
			description: "Enumerate every canonical neighborhood."
		},
		{
			key: "size2Only",
			label: "Only 2-color lists",
			description: "Keep situations where every node has a two-color list."
		},
		{
			key: "withSize3",
			label: "At least one 3-color list",
			description: "Keep situations that include at least one three-color list."
		}
	]

	const allRuleGroups = autogeneratedRules
	let selectedVariant = $state<SituationVariant>("all")

	const extractListSizes = (group: RuleGroup) => {
		const firstRule = group[0]
		if (!firstRule) return null
		return Array.from(firstRule.before.nodes).map(node => node.colors.length)
	}

	const matchesVariant = (group: RuleGroup, variant: SituationVariant) => {
		if (variant === "all") return true
		const sizes = extractListSizes(group)
		if (!sizes) return false
		if (variant === "size2Only") return sizes.every(size => size === 2)
		return sizes.some(size => size === 3)
	}

	const ruleGroups = $derived(
		selectedVariant === "all"
			? allRuleGroups
			: allRuleGroups.filter(group => matchesVariant(group, selectedVariant))
	)
	const allRules = $derived(ruleGroups.flat())
	const ruleMap = $derived(new Map(allRules.map(rule => [rule.name, rule])))
	const ruleAnalyses = $derived(analyzeRules(allRules))
	const ruleIndexMap = $derived(buildRuleIndexMap(allRules))
	const activeRuleNames = $derived(allRules.map(rule => rule.name))

	const targetSituations = $derived.by(() => {
		if (selectedVariant === "all") return ALL_LOCAL_SITUATIONS
		return ALL_LOCAL_SITUATIONS.filter(({ canon }) => {
			const sizes = Array.from(canon.nodes).map(node => node.colors.length)
			if (selectedVariant === "size2Only") return sizes.every(size => size === 2)
			return sizes.some(size => size === 3)
		})
	})

	const exhaustivenessReport = $derived.by(() => {
		const coverage = new Set<string>()
		for (const rule of allRules) {
			const { signature } = rule.before.canon()
			coverage.add(signature)
		}
		const missing = targetSituations
			.filter(situation => !coverage.has(situation.signature))
			.map(entry => entry.canon)
		const coveredCount = targetSituations.reduce(
			(count, situation) => count + (coverage.has(situation.signature) ? 1 : 0),
			0
		)
		return {
			exhaustive: missing.length === 0,
			missing,
			missingCount: missing.length,
			coveredCount,
			totalSituations: targetSituations.length
		}
	})

	const missingRuleSnippets = $derived(buildMissingRuleSnippets(exhaustivenessReport))
	const MAX_CANVAS_RENDER_PX = 420

	let userWeights = $state<WeightVector>({ w3: 1, w2: 0.6241 })
	let isWeightSearchRunning = $state(false)
	let weightGrid = $state<WeightGridCell[]>(buildInitialWeightGrid())
	let worker: Worker | null = null
	let searchVersion = 0

	let canvasEl: HTMLCanvasElement | null = null
	let ctx: CanvasRenderingContext2D | null = null
	let overlayCanvasEl: HTMLCanvasElement | null = null
	let overlayCtx: CanvasRenderingContext2D | null = null
	let imageData: ImageData | null = null
	let canvasDirty = false
	let flushScheduled = false
	let renderScale = 1
	let pendingHover: { x: number; y: number } | null = null
	let overlayDrawScheduled = false
	let lastDrawn: { x: number; y: number } | null = null
	let pendingCells: Array<{
		x: number
		y: number
		radius: number
		color: [number, number, number]
	}> = []
	let cellDrawScheduled = false
	const cellCache = new SvelteMap<number, WeightGridCell>()
	const w2ColumnCache = new SvelteMap<number, WeightGridCell>()
	let hoveredCell = $state<WeightGridCell | null>(null)
	let autoHoverCell: WeightGridCell | null = null
	let autoHoverBase: number | null = null
	let pointerActive = false
	const PENDING_RGB: [number, number, number] = [255, 255, 255]
	let resizeListener: (() => void) | null = null

	const hexToRgb = (hex: string): [number, number, number] => {
		const normalized = hex.replace("#", "")
		const num = parseInt(normalized, 16)
		return [(num >> 16) & 255, (num >> 8) & 255, num & 255]
	}

	const clampBaseValue = (base: number | null) => {
		if (base === null || Number.isNaN(base)) return 3
		if (base > 3) return 3
		if (base < 1) return 1
		return base
	}

	const baseToIndex = (base: number | null, axisCount: number = GRID_AXIS_COUNT) => {
		const clamped = clampBaseValue(base)
		const normalized = (clamped - 1) / 2
		const forward = Math.round(normalized * (axisCount - 1))
		return Math.min(axisCount - 1, Math.max(0, axisCount - 1 - forward))
	}

	const writePixel = (x: number, y: number, [r, g, b]: [number, number, number]) => {
		if (!imageData) return
		const idx = (y * GRID_AXIS_COUNT + x) * 4
		imageData.data[idx] = r
		imageData.data[idx + 1] = g
		imageData.data[idx + 2] = b
		imageData.data[idx + 3] = 255
	}

	const clearCanvasBuffer = () => {
		if (!imageData) return
		for (let i = 0; i < imageData.data.length; i += 4) {
			imageData.data[i] = PENDING_RGB[0]
			imageData.data[i + 1] = PENDING_RGB[1]
			imageData.data[i + 2] = PENDING_RGB[2]
			imageData.data[i + 3] = 255
		}
		canvasDirty = true
		scheduleFlushCanvas()
	}

	const scheduleFlushCanvas = () => {
		if (flushScheduled || !canvasDirty) return
		flushScheduled = true
		requestAnimationFrame(() => {
			flushScheduled = false
			if (ctx && imageData && canvasDirty) {
				ctx.putImageData(imageData, 0, 0)
				canvasDirty = false
			}
			if (canvasDirty) scheduleFlushCanvas()
		})
	}

	const initCanvas = () => {
		if (!canvasEl || !overlayCanvasEl) return
		ctx = canvasEl.getContext("2d")
		overlayCtx = overlayCanvasEl.getContext("2d")
		if (!ctx || !overlayCtx) return
		if (resizeListener) {
			window.removeEventListener("resize", resizeListener)
			resizeListener = null
		}
		ctx.imageSmoothingEnabled = false
		overlayCtx.imageSmoothingEnabled = false
		canvasEl.width = GRID_AXIS_COUNT
		canvasEl.height = GRID_AXIS_COUNT
		overlayCanvasEl.width = GRID_AXIS_COUNT
		overlayCanvasEl.height = GRID_AXIS_COUNT
		canvasEl.style.imageRendering = "pixelated"
		overlayCanvasEl.style.imageRendering = "pixelated"
		const resize = () => {
			const parentWidth =
				canvasEl?.parentElement?.clientWidth ?? canvasEl?.clientWidth ?? GRID_AXIS_COUNT
			const renderSize = Math.min(parentWidth, MAX_CANVAS_RENDER_PX)
			renderScale = renderSize / GRID_AXIS_COUNT
			canvasEl!.style.width = `${renderSize}px`
			canvasEl!.style.height = `${renderSize}px`
			overlayCanvasEl!.style.width = `${renderSize}px`
			overlayCanvasEl!.style.height = `${renderSize}px`
		}
		resize()
		resizeListener = () => resize()
		window.addEventListener("resize", resizeListener)
		imageData = ctx.createImageData(GRID_AXIS_COUNT, GRID_AXIS_COUNT)
		clearCanvasBuffer()
	}

	const writeCellToBuffer = (x: number, y: number, cell: WeightGridCell) => {
		if (!imageData) return
		const radius = Math.max(1, Math.round(1 / Math.max(renderScale, 0.0001)))
		const color = hexToRgb(cell.color)
		pendingCells.push({ x, y, radius, color })
		if (cellDrawScheduled) return
		cellDrawScheduled = true
		requestAnimationFrame(() => {
			if (!imageData) {
				cellDrawScheduled = false
				return
			}
			while (pendingCells.length) {
				const { x: cx, y: cy, radius: r, color } = pendingCells.pop()!
				const yStart = Math.max(0, cy - r)
				const yEnd = Math.min(GRID_AXIS_COUNT - 1, cy + r)
				const xStart = Math.max(0, cx - r)
				const xEnd = Math.min(GRID_AXIS_COUNT - 1, cx + r)
				for (let ny = yStart; ny <= yEnd; ny++) {
					for (let nx = xStart; nx <= xEnd; nx++) {
						writePixel(nx, ny, color)
					}
				}
			}
			canvasDirty = true
			scheduleFlushCanvas()
			cellDrawScheduled = false
		})
	}

	const handleCanvasHover = (event: MouseEvent) => {
		if (!canvasEl) return
		const rect = canvasEl.getBoundingClientRect()
		const scale = rect.width / GRID_AXIS_COUNT
		const x = Math.floor((event.clientX - rect.left) / scale)
		if (x < 0 || x >= GRID_AXIS_COUNT) {
			pointerActive = false
			applyAutoHover()
			return
		}
		const cell = w2ColumnCache.get(x)
		if (!cell) {
			pointerActive = false
			applyAutoHover()
			return
		}
		pointerActive = true
		hoveredCell = cell
		const base = cell.solution ? extractGrowthBase(cell.solution) : null
		const y = baseToIndex(base)
		drawHoverLine(x, y)
	}

	const clearOverlay = () => {
		if (!overlayCtx || !overlayCanvasEl) return
		overlayCtx.clearRect(0, 0, overlayCanvasEl.width, overlayCanvasEl.height)
		lastDrawn = null
	}

	const drawHoverLine = (x: number, y: number) => {
		if (!overlayCtx || !overlayCanvasEl) return
		if (lastDrawn && lastDrawn.x === x && lastDrawn.y === y) return
		pendingHover = { x, y }
		if (overlayDrawScheduled) return
		overlayDrawScheduled = true
		requestAnimationFrame(() => {
			if (!overlayCtx || !overlayCanvasEl || !pendingHover) {
				overlayDrawScheduled = false
				return
			}
			const { x: px, y: py } = pendingHover
			pendingHover = null
			clearOverlay()
			overlayCtx.strokeStyle = "rgba(17, 24, 39, 0.6)"
			const width = Math.max(2, Math.round(2 / Math.max(renderScale, 0.0001)))
			overlayCtx.lineWidth = width
			overlayCtx.beginPath()
			overlayCtx.moveTo(px + 0.5, GRID_AXIS_COUNT - 0.5)
			overlayCtx.lineTo(px + 0.5, py + 0.5)
			overlayCtx.stroke()
			lastDrawn = { x: px, y: py }
			overlayDrawScheduled = false
		})
	}

	const applyAutoHover = () => {
		if (!autoHoverCell) {
			clearOverlay()
			hoveredCell = null
			return
		}
		const base =
			autoHoverBase ?? (autoHoverCell.solution ? extractGrowthBase(autoHoverCell.solution) : null)
		if (base === null) {
			clearOverlay()
			hoveredCell = autoHoverCell
			return
		}
		const j = weightIndex(autoHoverCell.w2)
		const y = baseToIndex(base)
		hoveredCell = autoHoverCell
		drawHoverLine(j, y)
	}

	const resetGridState = () => {
		weightGrid = buildInitialWeightGrid()
		canvasDirty = false
		flushScheduled = false
		cellCache.clear()
		w2ColumnCache.clear()
		autoHoverCell = null
		autoHoverBase = null
		hoveredCell = null
		pointerActive = false
		pendingHover = null
		lastDrawn = null
		pendingCells = []
		cellDrawScheduled = false
		overlayDrawScheduled = false
	}

	const ensureCanvasReady = () => {
		if (!ctx || !overlayCtx || !imageData) initCanvas()
	}

	const restartWeightSearch = (activeNames: string[]) => {
		if (!browser) return
		if (!canvasEl || !overlayCanvasEl) return
		const version = ++searchVersion
		worker?.terminate()
		worker = null
		ensureCanvasReady()
		resetGridState()
		clearOverlay()
		clearCanvasBuffer()
		if (!activeNames.length) {
			isWeightSearchRunning = false
			return
		}
		isWeightSearchRunning = true
		let best: { weights: WeightVector | null; base: number } = {
			weights: null,
			base: Infinity
		}
		worker = new Worker(new URL("./weight-grid.ts", import.meta.url), { type: "module" })
		worker.onmessage = (event: MessageEvent<GridWorkerMessage>) => {
			if (version !== searchVersion) return
			const message = event.data
			if (message.type === "cell") {
				const { cell } = message as GridWorkerCellMessage
				const base = cell.solution ? extractGrowthBase(cell.solution) : null
				const i = baseToIndex(base)
				const j = weightIndex(cell.w2)
				weightGrid[j] = cell
				cellCache.set(j, cell)
				w2ColumnCache.set(j, cell)
				writeCellToBuffer(j, i, cell)
				if (base !== null && (autoHoverBase === null || base < autoHoverBase)) {
					autoHoverBase = base
					autoHoverCell = cell
					if (!pointerActive) {
						hoveredCell = autoHoverCell
						drawHoverLine(j, i)
					}
				}
				if (base !== null && (best.weights === null || base < best.base)) {
					best = { weights: { w3: cell.w3, w2: cell.w2 }, base }
				}
			} else if (message.type === "done") {
				const { bestWeights } = message as GridWorkerDoneMessage
				if (bestWeights) userWeights = bestWeights
				isWeightSearchRunning = false
			} else if (message.type === "error") {
				console.error(message.message)
				isWeightSearchRunning = false
			}
		}
		worker.onerror = err => {
			if (version !== searchVersion) return
			console.error(err)
			isWeightSearchRunning = false
		}
		const payload: GridWorkerInput = {
			type: "start",
			axisCount: GRID_AXIS_COUNT,
			step: GRID_SEARCH_STEP,
			activeRuleNames: activeNames,
			w3: 1
		}
		worker.postMessage(payload)
	}

	const weightedRecurrences = $derived(
		buildWeightedRecurrencesForWeights(userWeights, ruleAnalyses)
	)

	$effect(() => {
		if (!browser) return
		if (!canvasEl || !overlayCanvasEl) return
		restartWeightSearch(activeRuleNames)
	})

	const recurrenceSolutions = $derived(
		buildRecurrenceSolutionsForWeights(userWeights, weightedRecurrences)
	)

	type RuleCompatibilityIssue = { name: string; reason: string }
	const incompatibleRules = $derived(
		allRules
			.map(rule => {
				const idx = ruleIndexMap.get(rule.name)
				if (idx === undefined) return null
				const weighted = weightedRecurrences[idx]
				const solutionPromise = recurrenceSolutions[idx]
				if (weighted && solutionPromise) return null
				return {
					name: rule.name,
					reason: !weighted
						? "Selected weights do not decrease every branch."
						: "Recurrence solver unavailable for these weights."
				}
			})
			.filter((issue): issue is RuleCompatibilityIssue => issue !== null)
	)

	const limitingCell = $derived.by(() => {
		if (isWeightSearchRunning) return null
		const j = weightIndex(userWeights.w2)
		return w2ColumnCache.get(j) ?? null
	})

	const hoveredRule = $derived.by(() => {
		if (!hoveredCell || !hoveredCell.limitingRule) return null
		return ruleMap.get(hoveredCell.limitingRule) ?? null
	})

	const hoveredAnalysis = $derived.by(() => {
		if (!hoveredRule) return null
		const idx = ruleIndexMap.get(hoveredRule.name)
		return idx === undefined ? null : ruleAnalyses[idx]
	})

	onDestroy(() => {
		if (resizeListener) {
			window.removeEventListener("resize", resizeListener)
			resizeListener = null
		}
		worker?.terminate()
		worker = null
	})
</script>

<div class="mx-auto max-w-6xl space-y-12 sm:p-8">
	<h1 class="text-3xl font-bold">Branching Rules for List 3‑Coloring</h1>

	<p class="text-gray-700">
		Each rule below illustrates a local structure in a list-coloring instance, its branching
		options, and the resulting recurrence on the measures we track. After each rule you can inspect
		the recurrence, a weighted scalar reduction (when available), and the asymptotic solution
		produced by the recurrence solver.
	</p>

	<div class="rounded-lg border border-indigo-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-indigo-700 uppercase">Rule scope</div>
		<p class="mt-2">Choose which local situations to list and analyze.</p>
		<div class="mt-3 grid gap-3 md:grid-cols-3">
			{#each variantOptions as option (option.key)}
				<label
					class="flex cursor-pointer items-start gap-3 rounded-md border border-gray-200 bg-gray-50 p-3 transition hover:border-indigo-400">
					<input
						type="radio"
						class="mt-1 h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
						name="situation-variant"
						value={option.key}
						bind:group={selectedVariant} />
					<div class="space-y-1">
						<div class="text-sm font-semibold text-gray-800">{option.label}</div>
						<p class="text-xs text-gray-600">{option.description}</p>
					</div>
				</label>
			{/each}
		</div>
	</div>

	<div class="rounded-lg border border-gray-300 bg-gray-50 p-4 text-sm text-gray-800">
		<div class="font-semibold tracking-wide text-gray-600 uppercase">Legend</div>
		<ul class="mt-2 list-disc space-y-1 pl-5">
			<li>
				<span class="font-mono">n₃</span> — number of vertices whose lists still contain three colors
				and whose degree is at least three.
			</li>
			<li>
				<span class="font-mono">n₂</span> — number of vertices with two available colors and degree at
				least three.
			</li>
		</ul>
		(Neighbors of branching vertices are assumed to have degree at least three.)
	</div>

	<div class="rounded-lg border border-emerald-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-emerald-700 uppercase">Custom Measure</div>
		<p class="mt-2">
			Set the coefficients for <span class="font-mono">n₃</span> and
			<span class="font-mono">n₂</span>
			to define the scalar measure <span class="font-mono">n = c₃·n₃ + c₂·n₂</span> that the solver will
			use for every rule.
		</p>
		<div class="mt-4 grid gap-4 md:grid-cols-2">
			<label
				class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600 uppercase">
				<span>Coefficient c₃ (n₃)</span>
				<input
					type="number"
					min="0"
					step="0.1"
					class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
					bind:value={userWeights.w3} />
			</label>
			<label
				class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600 uppercase">
				<span>Coefficient c₂ (n₂)</span>
				<input
					type="number"
					min="0"
					step="0.1"
					class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
					bind:value={userWeights.w2} />
			</label>
		</div>
		<p class="mt-3 text-xs text-gray-500">
			Current measure: <span class="font-mono">n = {userWeights.w3}·n₃ + {userWeights.w2}·n₂</span>
		</p>
		{#if isWeightSearchRunning}
			<div class="mt-3 flex items-center gap-2 text-xs font-semibold text-emerald-700">
				<span
					class="inline-flex h-4 w-4 animate-spin rounded-full border-2 border-emerald-400 border-t-transparent"
					aria-hidden="true"></span>
				<span>Searching optimal weights…</span>
			</div>
		{/if}
	</div>

	<div class="rounded-lg border border-purple-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-purple-700 uppercase">
			Slowest Custom Solution
		</div>
		{#if limitingCell && limitingCell.limitingRule && limitingCell.solution}
			<p class="mt-2">
				Worst-case among active rules:
				<span class="font-semibold">{limitingCell.limitingRule}</span>
			</p>
			<p class="mt-1 font-mono text-base text-gray-800">{limitingCell.solution}</p>
		{:else}
			<p class="mt-2 text-gray-500">Enable at least one rule with a valid scalar recurrence.</p>
		{/if}
		{#if incompatibleRules.length}
			<div class="mt-3 space-y-1 text-xs text-amber-700">
				<p class="font-semibold tracking-wide uppercase">Incompatible measure for:</p>
				<ul class="list-disc space-y-1 pl-5">
					{#each incompatibleRules as issue (issue.name)}
						<li>
							<span class="font-semibold">{issue.name}</span>
							<span class="text-gray-600">— {issue.reason}</span>
						</li>
					{/each}
				</ul>
			</div>
		{/if}
	</div>

	<div class="rounded-lg border border-blue-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-blue-700 uppercase">Coverage Check</div>
		<p class="mt-2">
			Covered {exhaustivenessReport.coveredCount} of {exhaustivenessReport.totalSituations} canonical
			situations.
		</p>
		{#if exhaustivenessReport.exhaustive}
			<p class="mt-1 text-sm font-medium text-green-700">
				All eligible local situations are covered.
			</p>
		{:else}
			<p class="mt-1 text-sm font-medium text-red-700">
				Missing {exhaustivenessReport.missing.length} situations. Showing up to six examples below.
			</p>
			<div class="mt-4 grid gap-4 md:grid-cols-2">
				{#each exhaustivenessReport.missing.slice(0, 6) as situation (situation.signature())}
					<div class="space-y-2 rounded-lg border bg-gray-50 p-3">
						<div class="text-xs font-semibold text-gray-500 uppercase">Missing situation</div>
						<GraphView graph={situation} scale={0.55} />
					</div>
				{/each}
			</div>
		{/if}
	</div>

	<div class="rounded-lg border border-amber-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-amber-700 uppercase">Weight Explorer</div>
		<p class="mt-2">
			This plot plots the base b of the running time O(b^n) as a function of w₂. Hover to see the
			branching rule that limits the running time.
		</p>
		<div class="mt-4 space-y-3">
			<div class="relative">
				<canvas
					bind:this={canvasEl}
					class="mx-auto w-full overflow-hidden rounded border bg-white"
					onmousemove={handleCanvasHover}
					onmouseleave={() => {
						pointerActive = false
						applyAutoHover()
					}}
					aria-label="Weight grid heatmap"></canvas>
				<canvas
					bind:this={overlayCanvasEl}
					class="pointer-events-none absolute inset-0 mx-auto w-full overflow-hidden rounded border border-transparent"
					aria-hidden="true"></canvas>
			</div>
			<div class="rounded-lg border border-gray-200 bg-gray-50 p-3 text-xs text-gray-800">
				{#if hoveredCell}
					<div class="flex items-start gap-2">
						Limiting rule: <span
							class="mt-0.5 h-3.5 w-3.5 rounded-sm"
							style={`background-color: ${hoveredCell.color};`}
							aria-hidden="true"></span>
						<div class="space-y-1">
							<div class="text-sm font-semibold">
								{hoveredCell.limitingRule ?? "Invalid weights"}
							</div>
							<div class="font-mono text-sm text-gray-600">
								w₃={formatWeight(hoveredCell.w3)}, w₂={formatWeight(
									hoveredCell.w2
								)}{#if hoveredCell.solution}, {hoveredCell.solution}
								{:else}
									<span class="mt-2 text-sm text-red-600"
										>Weights do not decrease every branch.</span>
								{/if}
							</div>
						</div>
					</div>
					{#if hoveredRule}
						<div class="flex flex-row gap-4">
							<div class="mt-3 space-y-1">
								<div class="text-sm font-semibold text-gray-600">Local situation</div>
								<div class="mx-auto w-fit rounded border bg-white p-2">
									<GraphView graph={hoveredRule.before} scale={0.55} />
								</div>
							</div>
							{#if hoveredAnalysis}
								<div class="mt-3 space-y-2">
									<div class="text-sm font-semibold text-gray-600">Branches</div>
									<div class="flex flex-col flex-wrap gap-3">
										{#each hoveredRule.branches as branch (branch.assignments)}
											<div>{describeAssignments(branch.assignments)}</div>
										{/each}
									</div>
								</div>
							{/if}
						</div>
					{/if}
				{:else}
					<p class="text-xs text-gray-500">Hover a cell to see its limiting rule and recurrence.</p>
				{/if}
			</div>
			<div
				class="flex items-center justify-between text-[10px] font-semibold tracking-wide text-gray-500 uppercase">
				<span>Base increases ↑</span>
				<span>w₂ increases →</span>
			</div>
		</div>
		{#if isWeightSearchRunning}
			<p class="mt-3 text-xs text-amber-600">Filling grid with fresh evaluations…</p>
		{/if}
	</div>

	{#each allRules as rule, i (rule.name)}
		{@const analysis = ruleAnalyses[i]}
		<section class="space-y-8 overflow-clip rounded-xl border border-gray-300 p-6">
			<header class="flex flex-wrap items-start justify-between gap-4">
				<div>
					<h2 class="text-xl font-semibold">{rule.name}</h2>
					<p class="mt-1 text-gray-600">{rule.description}</p>
				</div>
			</header>

			<div class="rounded-lg border border-dashed bg-white p-4 text-sm">
				<div class="text-xs font-semibold tracking-wide text-gray-500 uppercase">Recurrence</div>
				<div class="font-mono text-base">{analysis.recurrenceDisplay}</div>

				<div class="mt-3 text-xs font-semibold tracking-wide text-gray-500 uppercase">
					Scalar Recurrence (custom measure)
				</div>
				{#if weightedRecurrences[i]}
					<div class="font-mono text-base">{weightedRecurrences[i]?.display}</div>
				{:else}
					<div class="text-sm text-red-600">
						The chosen coefficients do not decrease every branch.
					</div>
				{/if}

				<div class="mt-3 text-xs font-semibold tracking-wide text-gray-500 uppercase">Solution</div>
				<div class="font-mono text-base text-gray-800">
					{#if weightedRecurrences[i] && recurrenceSolutions[i]}
						{#await recurrenceSolutions[i]}
							<span class="text-gray-500">Computing…</span>
						{:then solution}
							{solution}
						{:catch error}
							<span class="text-red-600">
								{error instanceof Error ? error.message : String(error)}
							</span>
						{/await}
					{:else}
						<span class="text-red-600">Provide coefficients that decrease all branches.</span>
					{/if}
				</div>
			</div>

			<!-- BEFORE -->
			<div>
				<h3 class="mb-2 font-medium">Before branching</h3>
				<div class="mx-auto w-fit space-y-2 rounded-lg bg-gray-50 p-2 ring">
					<GraphView graph={rule.before} scale={0.55} />
				</div>
			</div>

			<!-- AFTER -->
			<div>
				<h3 class="mb-3 font-medium">After branching</h3>

				<div class="mx-auto flex flex-row flex-wrap justify-center gap-2">
					{#each rule.branches as branch, j (branch.assignments)}
						<div class="w-fit space-y-2 rounded-lg bg-gray-50 p-2 ring ring-amber-300">
							<div class="font-semibold">{describeAssignments(branch.assignments)}</div>
							<GraphView graph={analysis.branchDetails[j].after} scale={0.55} />
						</div>
					{/each}
				</div>
			</div>
		</section>
	{/each}

	{#if missingRuleSnippets.length}
		<section class="space-y-4 rounded-xl border border-gray-300 bg-white p-6">
			<header>
				<h2 class="text-xl font-semibold">Generated rule templates</h2>
				<p class="mt-1 text-gray-600">
					Copy any snippet below into <span class="font-mono">rules</span> to cover the remaining cases.
				</p>
			</header>
			<pre
				class="rounded-lg border bg-gray-50 p-4 font-mono text-xs leading-relaxed whitespace-pre-wrap">
				{missingRuleSnippets.join(",\n")}
			</pre>
		</section>
	{/if}
</div>
