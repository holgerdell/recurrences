<script lang="ts">
	import { onDestroy } from "svelte"
	import { SvelteMap, SvelteSet } from "svelte/reactivity"
	import { browser } from "$app/environment"
	import { ALL_LOCAL_SITUATIONS, AUTOGENERATED_RULES } from "$lib/coloring/3coloring-rules"
	import { buildMissingRuleSnippets } from "$lib/coloring/canon"
	import {
		describeAssignments,
		type BranchingRuleWithAnalysis,
		type WeightVector
	} from "$lib/coloring/rule-engine"
	import GraphView from "$lib/components/GraphView.svelte"
	import { solveRecurrencesFromStrings } from "$lib/recurrence-solver"
	import { formatAsymptotics } from "$lib/root-finding"
	import type { GridWorkerDoneMessage, GridWorkerInput, GridWorkerMessage } from "./weight-grid"
	import {
		buildRecurrenceSolutionsForWeights,
		buildRuleIndexMap,
		buildWeightedRecurrencesForWeights,
		formatWeight,
		GRID_AXIS_COUNT,
		GRID_SEARCH_STEP,
		ruleColorPalette,
		weightIndex,
		type WeightGridCell
	} from "./weight-grid-shared"

	type SituationVariant = "all" | "size2Only" | "withSize3"
	type ColorPalette = "12" | "123" | "1234"

	const variantOptions: Array<{
		key: SituationVariant
		label: string
		description: string
	}> = [
		{
			key: "all",
			label: "All local situations",
			description: "Enumerate every canonical neighborhood."
		},
		{
			key: "size2Only",
			label: "Only 2-color lists",
			description: "Keep situations where every node has a two-color list."
		},
		{
			key: "withSize3",
			label: "At least one 3-color list",
			description: "Keep situations that include at least one three-color list."
		}
	]

	const colorPaletteOptions: Array<{
		key: ColorPalette
		label: string
		description: string
		colors: readonly number[]
	}> = [
		{
			key: "12",
			label: "Colors {1,2}",
			description: "Only lists using colors 1 and 2.",
			colors: [1, 2]
		},
		{
			key: "123",
			label: "Colors {1,2,3}",
			description: "Lists using colors 1, 2, or 3.",
			colors: [1, 2, 3]
		},
		{
			key: "1234",
			label: "Colors {1,2,3,4}",
			description: "Lists using colors up to 4.",
			colors: [1, 2, 3, 4]
		}
	]

	const allRuleGroups = AUTOGENERATED_RULES
	let selectedVariant = $state<SituationVariant>("all")
	let selectedPalette = $state<ColorPalette>("123")

	const allowedColors = $derived(
		colorPaletteOptions.find(option => option.key === selectedPalette)?.colors ?? [1, 2, 3, 4]
	)

	const extractListSizes = (group: BranchingRuleWithAnalysis[]) => {
		const firstRule = group[0]
		if (!firstRule) return null
		return Array.from(firstRule.before.nodes).map(node => node.colors.length)
	}

	const matchesPalette = (group: BranchingRuleWithAnalysis[]) => {
		const firstRule = group[0]
		if (!firstRule) return false
		return Array.from(firstRule.before.nodes).every(node =>
			node.colors.every(color => allowedColors.includes(color))
		)
	}

	const matchesVariant = (group: BranchingRuleWithAnalysis[], variant: SituationVariant) => {
		if (variant === "all") return true
		const sizes = extractListSizes(group)
		if (!sizes) return false
		if (variant === "size2Only") return sizes.every(size => size === 2)
		return sizes.some(size => size === 3)
	}

	const ruleGroups = $derived(
		allRuleGroups
			.filter(group => matchesVariant(group, selectedVariant))
			.filter(group => matchesPalette(group))
	)
	const allRules = $derived(ruleGroups.flat())
	const ruleIndexMap = $derived(buildRuleIndexMap(allRules))
	const rulesBySituation = $derived(
		new Map(
			ruleGroups
				.filter(group => group.length > 0)
				.map(group => [group[0].situationId, group] as const)
		)
	)

	const colorFilteredSituations = $derived(
		ALL_LOCAL_SITUATIONS.filter(({ canon }) =>
			Array.from(canon.nodes).every(node =>
				node.colors.every(color => allowedColors.includes(color))
			)
		)
	)

	const targetSituations = $derived.by(() => {
		const source = colorFilteredSituations
		if (selectedVariant === "all") return source
		return source.filter(({ canon }) => {
			const sizes = Array.from(canon.nodes).map(node => node.colors.length)
			if (selectedVariant === "size2Only") return sizes.every(size => size === 2)
			return sizes.some(size => size === 3)
		})
	})

	const exhaustivenessReport = $derived.by(() => {
		const coverage = new SvelteSet<string>()
		for (const rule of allRules) {
			const { signature } = rule.before.canon()
			coverage.add(signature)
		}
		const missing = targetSituations
			.filter(situation => !coverage.has(situation.signature))
			.map(entry => entry.canon)
		const coveredCount = targetSituations.reduce(
			(count, situation) => count + (coverage.has(situation.signature) ? 1 : 0),
			0
		)
		return {
			exhaustive: missing.length === 0,
			missing,
			missingCount: missing.length,
			coveredCount,
			totalSituations: targetSituations.length
		}
	})

	const missingRuleSnippets = $derived(buildMissingRuleSnippets(exhaustivenessReport))
	const MAX_CANVAS_RENDER_PX = 420

	let userWeights = $state<WeightVector>({ w4: 1, w3: 1, w2: 0.6241 })
	let isWeightSearchRunning = $state(false)
	let weightGrid = $state<(WeightGridCell | null)[]>(Array(GRID_AXIS_COUNT).fill(null))

	// Precompute recurrence + solutions for all generated rules (unfiltered) so we can look them up by ruleId.
	const allGeneratedRules = AUTOGENERATED_RULES.flat()
	const generatedRuleIndexMap = $derived(
		new Map(allGeneratedRules.map((rule, idx) => [rule.ruleId, idx]))
	)
	const generatedWeightedRecurrences = $derived(
		buildWeightedRecurrencesForWeights(userWeights, allGeneratedRules)
	)
	const generatedRecurrenceSolutions = $derived(
		buildRecurrenceSolutionsForWeights(userWeights, generatedWeightedRecurrences)
	)

	let worker: Worker | null = null
	let searchVersion = 0

	let canvasEl: HTMLCanvasElement | null = null
	let ctx: CanvasRenderingContext2D | null = null
	let overlayCanvasEl: HTMLCanvasElement | null = null
	let overlayCtx: CanvasRenderingContext2D | null = null
	let imageData: ImageData | null = null
	let canvasDirty = false
	let flushScheduled = false
	let renderScale = 1
	let pendingHover: { x: number; y: number } | null = null
	let overlayDrawScheduled = false
	let lastDrawn: { x: number; y: number } | null = null
	let pendingCells: Array<{
		x: number
		y: number
		radius: number
		color: [number, number, number]
	}> = []
	let cellDrawScheduled = false
	const cellCache = new SvelteMap<number, WeightGridCell>()
	const w2ColumnCache = new SvelteMap<number, WeightGridCell>()
	let hoveredCell = $state<WeightGridCell | null>(null)
	let autoHoverCell: WeightGridCell | null = null
	let autoHoverBase: number | null = null
	let pointerActive = false
	const PENDING_RGB: [number, number, number] = [255, 255, 255]
	let resizeListener: (() => void) | null = null

	const hexToRgb = (hex: string): [number, number, number] => {
		const normalized = hex.replace("#", "")
		const num = parseInt(normalized, 16)
		return [(num >> 16) & 255, (num >> 8) & 255, num & 255]
	}

	const clampBaseValue = (base: number | null) => {
		if (base === null || Number.isNaN(base)) return 3
		if (base > 3) return 3
		if (base < 1) return 1
		return base
	}

	const baseToIndex = (base: number | null, axisCount: number = GRID_AXIS_COUNT) => {
		const clamped = clampBaseValue(base)
		const normalized = (clamped - 1) / 2
		const forward = Math.round(normalized * (axisCount - 1))
		return Math.min(axisCount - 1, Math.max(0, axisCount - 1 - forward))
	}

	const writePixel = (x: number, y: number, [r, g, b]: [number, number, number]) => {
		if (!imageData) return
		const idx = (y * GRID_AXIS_COUNT + x) * 4
		imageData.data[idx] = r
		imageData.data[idx + 1] = g
		imageData.data[idx + 2] = b
		imageData.data[idx + 3] = 255
	}

	const clearCanvasBuffer = () => {
		if (!imageData) return
		for (let i = 0; i < imageData.data.length; i += 4) {
			imageData.data[i] = PENDING_RGB[0]
			imageData.data[i + 1] = PENDING_RGB[1]
			imageData.data[i + 2] = PENDING_RGB[2]
			imageData.data[i + 3] = 255
		}
		canvasDirty = true
		scheduleFlushCanvas()
	}

	const scheduleFlushCanvas = () => {
		if (flushScheduled || !canvasDirty) return
		flushScheduled = true
		requestAnimationFrame(() => {
			flushScheduled = false
			if (ctx && imageData && canvasDirty) {
				ctx.putImageData(imageData, 0, 0)
				canvasDirty = false
			}
			if (canvasDirty) scheduleFlushCanvas()
		})
	}

	const initCanvas = () => {
		if (!canvasEl || !overlayCanvasEl) return
		ctx = canvasEl.getContext("2d")
		overlayCtx = overlayCanvasEl.getContext("2d")
		if (!ctx || !overlayCtx) return
		if (resizeListener) {
			window.removeEventListener("resize", resizeListener)
			resizeListener = null
		}
		ctx.imageSmoothingEnabled = false
		overlayCtx.imageSmoothingEnabled = false
		canvasEl.width = GRID_AXIS_COUNT
		canvasEl.height = GRID_AXIS_COUNT
		overlayCanvasEl.width = GRID_AXIS_COUNT
		overlayCanvasEl.height = GRID_AXIS_COUNT
		canvasEl.style.imageRendering = "pixelated"
		overlayCanvasEl.style.imageRendering = "pixelated"
		const resize = () => {
			const parentWidth =
				canvasEl?.parentElement?.clientWidth ?? canvasEl?.clientWidth ?? GRID_AXIS_COUNT
			const renderSize = Math.min(parentWidth, MAX_CANVAS_RENDER_PX)
			renderScale = renderSize / GRID_AXIS_COUNT
			canvasEl!.style.width = `${renderSize}px`
			canvasEl!.style.height = `${renderSize}px`
			overlayCanvasEl!.style.width = `${renderSize}px`
			overlayCanvasEl!.style.height = `${renderSize}px`
		}
		resize()
		resizeListener = () => resize()
		window.addEventListener("resize", resizeListener)
		imageData = ctx.createImageData(GRID_AXIS_COUNT, GRID_AXIS_COUNT)
		clearCanvasBuffer()
	}

	const writeCellToBuffer = (x: number, y: number) => {
		if (!imageData) return
		const radius = Math.max(1, Math.round(1 / Math.max(renderScale, 0.0001)))
		const color = hexToRgb(ruleColorPalette[0])
		pendingCells.push({ x, y, radius, color })
		if (cellDrawScheduled) return
		cellDrawScheduled = true
		requestAnimationFrame(() => {
			if (!imageData) {
				cellDrawScheduled = false
				return
			}
			while (pendingCells.length) {
				const { x: cx, y: cy, radius: r, color } = pendingCells.pop()!
				const yStart = Math.max(0, cy - r)
				const yEnd = Math.min(GRID_AXIS_COUNT - 1, cy + r)
				const xStart = Math.max(0, cx - r)
				const xEnd = Math.min(GRID_AXIS_COUNT - 1, cx + r)
				for (let ny = yStart; ny <= yEnd; ny++) {
					for (let nx = xStart; nx <= xEnd; nx++) {
						writePixel(nx, ny, color)
					}
				}
			}
			canvasDirty = true
			scheduleFlushCanvas()
			cellDrawScheduled = false
		})
	}

	const handleCanvasHover = (event: MouseEvent) => {
		if (!canvasEl) return
		const rect = canvasEl.getBoundingClientRect()
		const scale = rect.width / GRID_AXIS_COUNT
		const x = Math.floor((event.clientX - rect.left) / scale)
		if (x < 0 || x >= GRID_AXIS_COUNT) {
			pointerActive = false
			applyAutoHover()
			return
		}
		const cell = w2ColumnCache.get(x)
		if (!cell) {
			pointerActive = false
			applyAutoHover()
			return
		}
		pointerActive = true
		hoveredCell = cell
		const base = cell.maxBase
		const y = baseToIndex(base)
		drawHoverLine(x, y)
	}

	const clearOverlay = () => {
		if (!overlayCtx || !overlayCanvasEl) return
		overlayCtx.clearRect(0, 0, overlayCanvasEl.width, overlayCanvasEl.height)
		lastDrawn = null
	}

	const drawHoverLine = (x: number, y: number) => {
		if (!overlayCtx || !overlayCanvasEl) return
		if (lastDrawn && lastDrawn.x === x && lastDrawn.y === y) return
		pendingHover = { x, y }
		if (overlayDrawScheduled) return
		overlayDrawScheduled = true
		requestAnimationFrame(() => {
			if (!overlayCtx || !overlayCanvasEl || !pendingHover) {
				overlayDrawScheduled = false
				return
			}
			const { x: px, y: py } = pendingHover
			pendingHover = null
			clearOverlay()
			overlayCtx.strokeStyle = "rgba(17, 24, 39, 0.6)"
			const width = Math.max(2, Math.round(2 / Math.max(renderScale, 0.0001)))
			overlayCtx.lineWidth = width
			overlayCtx.beginPath()
			overlayCtx.moveTo(px + 0.5, GRID_AXIS_COUNT - 0.5)
			overlayCtx.lineTo(px + 0.5, py + 0.5)
			overlayCtx.stroke()
			lastDrawn = { x: px, y: py }
			overlayDrawScheduled = false
		})
	}

	const applyAutoHover = () => {
		if (!autoHoverCell) {
			clearOverlay()
			hoveredCell = null
			return
		}
		const base = autoHoverBase ?? autoHoverCell.maxBase
		if (base === null) {
			clearOverlay()
			hoveredCell = autoHoverCell
			return
		}
		const j = weightIndex(autoHoverCell.w.w2)
		const y = baseToIndex(base)
		hoveredCell = autoHoverCell
		drawHoverLine(j, y)
	}

	const resetGridState = () => {
		weightGrid = Array(GRID_AXIS_COUNT).fill(null)
		canvasDirty = false
		flushScheduled = false
		cellCache.clear()
		w2ColumnCache.clear()
		autoHoverCell = null
		autoHoverBase = null
		hoveredCell = null
		pointerActive = false
		pendingHover = null
		lastDrawn = null
		pendingCells = []
		cellDrawScheduled = false
		overlayDrawScheduled = false
	}

	const ensureCanvasReady = () => {
		if (!ctx || !overlayCtx || !imageData) initCanvas()
	}

	const restartWeightSearch = () => {
		if (!browser) return
		if (!canvasEl || !overlayCanvasEl) return
		const version = ++searchVersion
		worker?.terminate()
		worker = null
		ensureCanvasReady()
		resetGridState()
		clearOverlay()
		clearCanvasBuffer()
		isWeightSearchRunning = true
		let best: { weights: WeightVector | null; base: number } = {
			weights: null,
			base: Infinity
		}
		worker = new Worker(new URL("./weight-grid.ts", import.meta.url), { type: "module" })
		worker.onmessage = (event: MessageEvent<GridWorkerMessage>) => {
			if (version !== searchVersion) return
			const message = event.data
			if (message.type === "cell") {
				const { cell } = message
				const base = cell.maxBase
				const i = baseToIndex(base)
				const j = weightIndex(cell.w.w2)
				weightGrid[j] = cell
				cellCache.set(j, cell)
				w2ColumnCache.set(j, cell)
				writeCellToBuffer(j, i)
				if (base !== null && (autoHoverBase === null || base < autoHoverBase)) {
					autoHoverBase = base
					autoHoverCell = cell
					if (!pointerActive) {
						hoveredCell = autoHoverCell
						drawHoverLine(j, i)
					}
				}
				if (base !== null && (best.weights === null || base < best.base)) {
					best = { weights: cell.w, base }
				}
			} else if (message.type === "done") {
				const { bestWeights } = message as GridWorkerDoneMessage
				if (bestWeights) userWeights = bestWeights
				isWeightSearchRunning = false
			} else if (message.type === "error") {
				console.error(message.message)
				isWeightSearchRunning = false
			}
		}
		worker.onerror = err => {
			if (version !== searchVersion) return
			console.error(err)
			isWeightSearchRunning = false
		}
		const payload: GridWorkerInput = {
			type: "start",
			axisCount: GRID_AXIS_COUNT,
			step: GRID_SEARCH_STEP,
			ruleGroups,
			w: { w4: 1, w3: selectedPalette === "1234" ? undefined : 1 }
		}
		worker.postMessage(payload)
	}

	const weightedRecurrences = $derived(buildWeightedRecurrencesForWeights(userWeights, allRules))

	$effect(() => {
		if (!browser) return
		if (!canvasEl || !overlayCanvasEl) return
		restartWeightSearch()
	})

	const recurrenceSolutions = $derived(
		weightedRecurrences.map(x => x?.equation || "").map(solveRecurrencesFromStrings)
	)

	const generatedGetRuleSolution = (ruleId: number) => {
		const idx = generatedRuleIndexMap.get(ruleId)
		if (idx === undefined) return null
		return {
			weighted: generatedWeightedRecurrences[idx],
			solution: generatedRecurrenceSolutions[idx]
		}
	}

	type RuleCompatibilityIssue = { name: string; reason: string }
	const incompatibleRules = $derived.by(async () => {
		const solutions = await Promise.all(recurrenceSolutions)
		return allRules
			.map(rule => {
				const idx = ruleIndexMap.get(rule.name)
				if (idx === undefined) return null
				const weighted = weightedRecurrences[idx]
				const solution = solutions[idx]
				if (weighted && solution.ok && !solution.divergent) return null
				return {
					name: rule.name,
					reason: !weighted
						? "Selected weights do not decrease every branch."
						: "Recurrence solver unavailable for these weights."
				}
			})
			.filter((issue): issue is RuleCompatibilityIssue => issue !== null)
	})

	const limitingCell = $derived.by(() => {
		const j = weightIndex(userWeights.w2)
		return w2ColumnCache.get(j) ?? null
	})

	const hoveredRule = $derived.by(() => {
		if (!hoveredCell) return null
		return allRuleGroups[hoveredCell.limitingSituationId].find(
			r => r.ruleId === hoveredCell?.limitingRuleId
		)
	})

	onDestroy(() => {
		if (resizeListener) {
			window.removeEventListener("resize", resizeListener)
			resizeListener = null
		}
		worker?.terminate()
		worker = null
	})
</script>

<div class="mx-auto max-w-6xl space-y-12 sm:p-8">
	<h1 class="text-3xl font-bold">Branching Rules for List 3‑Coloring</h1>

	<p class="text-gray-700">
		Each rule below illustrates a local structure in a list-coloring instance, its branching
		options, and the resulting recurrence on the measures we track. After each rule you can inspect
		the recurrence, a weighted scalar reduction (when available), and the asymptotic solution
		produced by the recurrence solver.
	</p>

	<div class="rounded-lg border border-indigo-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-indigo-700 uppercase">Rule scope</div>
		<p class="mt-2">Choose which local situations to list and analyze.</p>
		<div class="mt-3 grid gap-3 md:grid-cols-3">
			{#each variantOptions as option (option.key)}
				<label
					class="flex cursor-pointer items-start gap-3 rounded-md border border-gray-200 bg-gray-50 p-3 transition hover:border-indigo-400">
					<input
						type="radio"
						class="mt-1 h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
						name="situation-variant"
						value={option.key}
						bind:group={selectedVariant} />
					<div class="space-y-1">
						<div class="text-sm font-semibold text-gray-800">{option.label}</div>
						<p class="text-xs text-gray-600">{option.description}</p>
					</div>
				</label>
			{/each}
		</div>

		<div class="mt-6 space-y-2">
			<div class="text-xs font-semibold tracking-wide text-indigo-700 uppercase">
				Allowed colors
			</div>
			<div class="grid gap-3 md:grid-cols-3">
				{#each colorPaletteOptions as option (option.key)}
					<label
						class="flex cursor-pointer items-start gap-3 rounded-md border border-gray-200 bg-gray-50 p-3 transition hover:border-indigo-400">
						<input
							type="radio"
							class="mt-1 h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
							name="color-palette"
							value={option.key}
							bind:group={selectedPalette} />
						<div class="space-y-1">
							<div class="text-sm font-semibold text-gray-800">{option.label}</div>
							<p class="text-xs text-gray-600">{option.description}</p>
						</div>
					</label>
				{/each}
			</div>
		</div>
	</div>

	<div class="rounded-lg border border-gray-300 bg-gray-50 p-4 text-sm text-gray-800">
		<div class="font-semibold tracking-wide text-gray-600 uppercase">Legend</div>
		<ul class="mt-2 list-disc space-y-1 pl-5">
			<li>
				<span class="font-mono">n₄</span> — number of vertices whose lists contain four colors and whose
				degree is at least three.
			</li>
			<li>
				<span class="font-mono">n₃</span> — number of vertices whose lists contain three colors and whose
				degree is at least three.
			</li>
			<li>
				<span class="font-mono">n₂</span> — number of vertices whose lists contain two colors and whose
				degree is at least three.
			</li>
		</ul>
		<p>(Separator vertices are assumed to have degree at least three.)</p>
	</div>

	<div class="rounded-lg border border-emerald-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-emerald-700 uppercase">Custom Measure</div>
		<p class="mt-2">
			Set the coefficients for <span class="font-mono">n₄</span>,
			<span class="font-mono">n₃</span>, and
			<span class="font-mono">n₂</span>
			to define the scalar measure <span class="font-mono">n = c₄·n₄ + c₃·n₃ + c₂·n₂</span> that the solver
			will use for every rule.
		</p>
		<div class="mt-4 grid gap-4 md:grid-cols-3">
			<label
				class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600 uppercase">
				<span>Coefficient c₄ (n₄)</span>
				<input
					type="number"
					min="0"
					step="0.1"
					class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
					bind:value={userWeights.w4} />
			</label>
			<label
				class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600 uppercase">
				<span>Coefficient c₃ (n₃)</span>
				<input
					type="number"
					min="0"
					step="0.1"
					class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
					bind:value={userWeights.w3} />
			</label>
			<label
				class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600 uppercase">
				<span>Coefficient c₂ (n₂)</span>
				<input
					type="number"
					min="0"
					step="0.1"
					class="rounded border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
					bind:value={userWeights.w2} />
			</label>
		</div>
		<p class="mt-3 text-xs text-gray-500">
			Current measure:
			<span class="font-mono"
				>n = {userWeights.w4}·n₄ + {userWeights.w3}·n₃ + {userWeights.w2}·n₂</span>
		</p>
		{#if isWeightSearchRunning}
			<div class="mt-3 flex items-center gap-2 text-xs font-semibold text-emerald-700">
				<span
					class="inline-flex h-4 w-4 animate-spin rounded-full border-2 border-emerald-400 border-t-transparent"
					aria-hidden="true"></span>
				<span>Searching optimal weights…</span>
			</div>
		{/if}
	</div>

	<div class="rounded-lg border border-purple-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-purple-700 uppercase">
			Slowest Custom Solution
		</div>
		{#if limitingCell}
			<p class="mt-2">
				Worst-case among active rules:
				<span class="font-semibold">{limitingCell.limitingRuleId}</span>
			</p>
			<p class="mt-1 font-mono text-base text-gray-800">{limitingCell.maxBase}<sup>n</sup></p>
		{:else}
			<p class="mt-2 text-gray-500">Enable at least one rule with a valid scalar recurrence.</p>
		{/if}
		{#await incompatibleRules then inc}
			{#if inc.length}
				<div class="mt-3 space-y-1 text-xs text-amber-700">
					<p class="font-semibold tracking-wide uppercase">Incompatible measure for:</p>
					<ul class="list-disc space-y-1 pl-5">
						{#each inc as issue (issue.name)}
							<li>
								<span class="font-semibold">{issue.name}</span>
								<span class="text-gray-600">— {issue.reason}</span>
							</li>
						{/each}
					</ul>
				</div>
			{/if}
		{/await}
	</div>

	<div class="rounded-lg border border-blue-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-blue-700 uppercase">Coverage Check</div>
		<p class="mt-2">
			Covered {exhaustivenessReport.coveredCount} of {exhaustivenessReport.totalSituations} canonical
			situations.
		</p>
		{#if exhaustivenessReport.exhaustive}
			<p class="mt-1 text-sm font-medium text-green-700">
				All eligible local situations are covered.
			</p>
		{:else}
			<p class="mt-1 text-sm font-medium text-red-700">
				Missing {exhaustivenessReport.missing.length} situations. Showing up to six examples below.
			</p>
			<div class="mt-4 grid gap-4 md:grid-cols-2">
				{#each exhaustivenessReport.missing.slice(0, 6) as situation (situation.signature())}
					<div class="space-y-2 rounded-lg border bg-gray-50 p-3">
						<div class="text-xs font-semibold text-gray-500 uppercase">Missing situation</div>
						<GraphView graph={situation} scale={0.55} />
					</div>
				{/each}
			</div>
		{/if}
	</div>

	<div class="rounded-lg border border-amber-200 bg-white p-4 text-sm text-gray-800">
		<div class="text-xs font-semibold tracking-wide text-amber-700 uppercase">Weight Explorer</div>
		<p class="mt-2">
			This plot plots the base b of the running time O(b^n) as a function of w₂. Hover to see the
			branching rule that limits the running time.
		</p>
		<div class="mt-4 space-y-3">
			<div class="relative">
				<canvas
					bind:this={canvasEl}
					class="mx-auto w-full overflow-hidden rounded border bg-white"
					onmousemove={handleCanvasHover}
					onmouseleave={() => {
						pointerActive = false
						applyAutoHover()
					}}
					aria-label="Weight grid heatmap"></canvas>
				<canvas
					bind:this={overlayCanvasEl}
					class="pointer-events-none absolute inset-0 mx-auto w-full overflow-hidden rounded border border-transparent"
					aria-hidden="true"></canvas>
			</div>
			<div class="rounded-lg border border-gray-200 bg-gray-50 p-3 text-xs text-gray-800">
				{#if hoveredCell}
					<div class="flex items-start gap-2">
						Limiting rule: <span
							class="mt-0.5 h-3.5 w-3.5 rounded-sm"
							style={`background-color: ${ruleColorPalette[0]};`}
							aria-hidden="true"></span>
						<div class="space-y-1">
							<div class="text-sm font-semibold">
								{hoveredCell.limitingRuleId ?? "Invalid weights"}
							</div>
							<div class="font-mono text-sm text-gray-600">
								w4={formatWeight(hoveredCell.w.w4)}, w₃={formatWeight(hoveredCell.w.w3)}, w₂={formatWeight(
									hoveredCell.w.w2
								)}{#if hoveredCell}, {hoveredCell.maxBase}<sup>n</sup>
								{:else}
									<span class="mt-2 text-sm text-red-600"
										>Weights do not decrease every branch.</span>
								{/if}
							</div>
						</div>
					</div>
					{#if hoveredRule}
						<div class="flex flex-row gap-4">
							<div class="mt-3 space-y-1">
								<div class="text-sm font-semibold text-gray-600">Local situation</div>
								<div class="mx-auto w-fit rounded border bg-white p-2">
									<GraphView graph={hoveredRule.before} scale={0.55} />
								</div>
							</div>
							{#if hoveredRule}
								<div class="mt-3 space-y-2">
									<div class="text-sm font-semibold text-gray-600">Branches</div>
									<div class="flex flex-col flex-wrap gap-3">
										{#each hoveredRule.branches as branch (branch.assignments)}
											<div>{describeAssignments(branch.assignments)}</div>
										{/each}
									</div>
								</div>
							{/if}
						</div>
					{/if}
				{:else}
					<p class="text-xs text-gray-500">Hover a cell to see its limiting rule and recurrence.</p>
				{/if}
			</div>
			<div
				class="flex items-center justify-between text-[10px] font-semibold tracking-wide text-gray-500 uppercase">
				<span>Base increases ↑</span>
				<span>w₂ increases →</span>
			</div>
		</div>
		{#if isWeightSearchRunning}
			<p class="mt-3 text-xs text-amber-600">Filling grid with fresh evaluations…</p>
		{/if}
	</div>

	<section class="space-y-6 rounded-xl border border-gray-300 bg-white p-6">
		<header class="space-y-2">
			<h2 class="text-xl font-semibold">Canonical situations</h2>
			<p class="text-gray-600">
				Showing {targetSituations.length} situations filtered by scope and palette. Each card lists the
				rules available for that situation.
			</p>
		</header>

		<div class="grid gap-6 md:grid-cols-2">
			{#each targetSituations as s (s.signature)}
				{@const rulesForSituation =
					rulesBySituation.get(s.situationId) ?? AUTOGENERATED_RULES[s.situationId] ?? []}
				<div class="space-y-4 rounded-lg border bg-gray-50 p-4">
					<div class="flex items-start justify-between gap-3">
						<div class="space-y-1">
							<div class="font-semibold tracking-wide text-gray-800 uppercase">
								Situation {s.situationId}
							</div>
						</div>
					</div>

					<div class="w-fit rounded border border-dotted bg-white p-2">
						<GraphView graph={s.canon ?? s} scale={0.6} />
					</div>

					<div class="space-y-3">
						{#if rulesForSituation.length === 0}
							<p class="text-xs text-gray-500">No rules available for this situation.</p>
						{:else}
							{#each rulesForSituation as rule (rule.ruleId)}
								{@const solved = generatedGetRuleSolution(rule.ruleId)}
								<div
									class="space-y-2 rounded border border-dashed bg-white p-3 text-sm text-gray-800">
									<div
										class="flex flex-wrap items-baseline gap-2 text-sm font-semibold tracking-wide text-gray-800">
										<span class="uppercase">Rule {rule.ruleId}:</span>
										<div class="flex flex-wrap items-center gap-2">
											{#each rule.branches as branch, idx (branch.assignments)}
												{#if idx > 0}
													<span class="text-gray-400">|</span>
												{/if}
												<span>{describeAssignments(branch.assignments)}</span>
											{/each}
										</div>
									</div>
									<div class="text-gray-900">{rule.recurrenceDisplay}</div>
									<div class="flex flex-wrap items-baseline gap-2">
										<span>Solution:</span>
										<span>
											{#if solved?.weighted}
												{#await solved.solution}
													<span class="text-gray-500">Computing…</span>
												{:then solution}
													{#if solution?.ok && !solution?.divergent}
														{formatAsymptotics(solution.root)}
													{:else if solution?.ok}
														divergent
													{:else}
														<span class="text-red-600">{solution?.error ?? "Solver error"}</span>
													{/if}
												{:catch error}
													<span class="text-red-600"
														>{error instanceof Error ? error.message : String(error)}</span>
												{/await}
											{:else}
												<span class="text-red-600"
													>Provide coefficients that decrease all branches.</span>
											{/if}
										</span>
									</div>
								</div>
							{/each}
						{/if}
					</div>
				</div>
			{/each}
		</div>
	</section>

	{#if missingRuleSnippets.length}
		<section class="space-y-4 rounded-xl border border-gray-300 bg-white p-6">
			<header>
				<h2 class="text-xl font-semibold">Generated rule templates</h2>
				<p class="mt-1 text-gray-600">
					Copy any snippet below into <span class="font-mono">rules</span> to cover the remaining cases.
				</p>
			</header>
			<pre
				class="rounded-lg border bg-gray-50 p-4 font-mono text-xs leading-relaxed whitespace-pre-wrap">
				{missingRuleSnippets.join(",\n")}
			</pre>
		</section>
	{/if}
</div>
