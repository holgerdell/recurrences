import { autogeneratedRules } from "$lib/coloring/3coloring-rules"
import { analyzeRules } from "$lib/coloring/rule-engine"
import type { WeightVector } from "$lib/coloring/rule-engine"
import {
	axisValue,
	buildCell,
	buildRuleColorMap,
	buildRuleIndexMap,
	extractGrowthBase,
	GRID_AXIS_COUNT,
	GRID_SEARCH_STEP,
	type WeightGridCell
} from "./weight-grid-shared"

export type GridWorkerInput = {
	type: "start"
	activeRuleNames: string[]
	w3?: number
	w2?: number
	axisCount?: number
	step?: number
}

export type GridWorkerCellMessage = {
	type: "cell"
	cell: WeightGridCell
}

export type GridWorkerDoneMessage = {
	type: "done"
	bestWeights: WeightVector | null
	bestBase: number | null
}

export type GridWorkerErrorMessage = {
	type: "error"
	message: string
}

export type GridWorkerMessage =
	| GridWorkerCellMessage
	| GridWorkerDoneMessage
	| GridWorkerErrorMessage

const ruleGroups = autogeneratedRules
const ruleGroupNames = ruleGroups.map(group => group.map(rule => rule.name))
const allRules = ruleGroups.flat()
const ruleAnalyses = analyzeRules(allRules)
const ruleIndexMap = buildRuleIndexMap(allRules)
const ruleColorMap = buildRuleColorMap(allRules)

self.onmessage = async (event: MessageEvent<GridWorkerInput>) => {
	if (event.data?.type !== "start") return
	const {
		activeRuleNames,
		axisCount = GRID_AXIS_COUNT,
		step = GRID_SEARCH_STEP,
		w3: fixedW3,
		w2: fixedW2
	} = event.data

	try {
		let best: { weights?: WeightVector; base: number } = { base: Infinity }

		const w3Values = (() => {
			if (fixedW3 !== undefined) return [fixedW3]
			return Array.from({ length: axisCount }, (_, i) => axisValue(i, axisCount, step))
		})()

		const w2Values = (() => {
			if (fixedW2 !== undefined) return [fixedW2]
			return Array.from({ length: axisCount }, (_, j) => axisValue(j, axisCount, step))
		})()

		for (const w3 of w3Values) {
			for (const w2 of w2Values) {
				const cell = await buildCell({
					w3,
					w2,
					activeRuleNames,
					ruleGroups: ruleGroupNames,
					ruleIndexMap,
					analyses: ruleAnalyses,
					ruleColorMap
				})
				self.postMessage({ type: "cell", cell })
				const base = cell.solution ? extractGrowthBase(cell.solution) : null
				if (base !== null && base < best.base) {
					best = { weights: { w3: cell.w3, w2: cell.w2 }, base }
				}
			}
		}
		const done: GridWorkerDoneMessage = {
			type: "done",
			bestWeights: best?.weights ?? null,
			bestBase: best?.base ?? null
		}
		self.postMessage(done)
	} catch (error) {
		const message: GridWorkerErrorMessage = {
			type: "error",
			message: error instanceof Error ? error.message : String(error)
		}
		self.postMessage(message)
	}
}
