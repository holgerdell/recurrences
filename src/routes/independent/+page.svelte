<script lang="ts">
	import { onDestroy } from "svelte"
	import { browser } from "$app/environment"
	import { formatMeasure } from "$lib/coloring/feature-space"
	import type { Graph } from "$lib/coloring/graph"
	import {
		analyzeRule,
		autogenerateRules,
		buildRecurrenceStrings,
		buildScalarRecurrence,
		describeAssignments,
		type BranchingRule,
		type BranchingRuleWithAnalysis	} from "$lib/coloring/rule-engine"
	import { type FeatureVector } from "$lib/coloring/feature-space"
	import BasicSubscripts from "$lib/components/BasicSubscripts.svelte"
	import GraphView from "$lib/components/GraphView.svelte"
	import { formatAsymptotics } from "$lib/polynomial-system-solver"
	import { solveRecurrencesFromStrings } from "$lib/recurrence-solver"
	import { formatMillis, formatNumber, formatPercent, map2D } from "$lib/utils"
	import { OptimizationManager } from "$lib/vector-optimizer-manager"
	import { createDegreeFeatureSpace } from "./degree-feature-space"
	import { enumerateIndependentSetLocalSituations } from "./independent-set-enumeration"

	type LocalSituation = {
		canon: Graph
		situationId: number
		signature: string
	}

	/**
	 * Memoized list of canonical situations (computed asynchronously for progress reporting).
	 */
	const ALL_LOCAL_SITUATIONS: LocalSituation[] = []

	/**
	 * Memoized list of autogenerated rules for each situation.
	 */
	const AUTOGENERATED_RULES: BranchingRule[][] = []

	/**
	 * Reactive state tracking the progress of situation computation.
	 */
	let localSituationsStatus = $state({
		loading: true,
		computed: 0,
		success: 0,
		elapsedMs: 0
	})

	let computeSituationsVersion = 0

	/**
	 * Asynchronously computes all canonical local situations and their branching rules.
	 * Reports progress to the UI and yields to the main thread to keep the UI responsive.
	 */
	const computeSituations = async () => {
		if (!browser) return
		const version = ++computeSituationsVersion
		localSituationsStatus.loading = true
		localSituationsStatus.computed = 0
		localSituationsStatus.success = 0
		localSituationsStatus.elapsedMs = 0
		ALL_LOCAL_SITUATIONS.length = 0
		AUTOGENERATED_RULES.length = 0

		const start = performance.now()
		/**
		 * Yields control back to the UI thread.
		 */
		const yieldToUI = () =>
			new Promise<void>(resolve => {
				if (typeof requestAnimationFrame === "function") requestAnimationFrame(() => resolve())
				else setTimeout(resolve, 0)
			})

		const situationMaxDegree = maxDegree + 1
		let counter = 0
		for (const G of enumerateIndependentSetLocalSituations({
			minDegree: 3,
			maxDegree: situationMaxDegree,
			depth
		})) {
			if (version !== computeSituationsVersion) return
			const situation: LocalSituation = {
				canon: G,
				situationId: counter,
				signature: G.signature ?? `#${counter}`
			}
			const rules = autogenerateRules(situation)
			ALL_LOCAL_SITUATIONS.push(situation)
			AUTOGENERATED_RULES.push(rules)
			counter += 1
			if (counter % 100 === 0) {
				localSituationsStatus.computed = counter
				await yieldToUI()
				if (version !== computeSituationsVersion) return
			}
		}
		if (version !== computeSituationsVersion) return
		localSituationsStatus.success = ALL_LOCAL_SITUATIONS.length
		localSituationsStatus.elapsedMs = performance.now() - start
		localSituationsStatus.loading = false
	}

	const problem = "independent set" as const

	let depthInput = $state(2)
	let maxDegreeInput = $state(5)
	const depth = $derived.by(() => {
		const n = Number(depthInput)
		if (!Number.isFinite(n)) return 2
		return Math.max(1, Math.floor(n))
	})
	const maxDegree = $derived.by(() => {
		const n = Number(maxDegreeInput)
		if (!Number.isFinite(n)) return 5
		return Math.max(3, Math.floor(n))
	})
	const degreeFeatureSpace = $derived.by(() => createDegreeFeatureSpace(maxDegree))
	$effect(() => {
		// Keep the input displaying the normalized value.
		if (Number(depthInput) !== depth) depthInput = depth
	})
	$effect(() => {
		// Keep the input displaying the normalized value.
		if (Number(maxDegreeInput) !== maxDegree) maxDegreeInput = maxDegree
	})

	const fixedPartialMeasure: FeatureVector = {}

	function buildDefaultBounds(fixed: FeatureVector) {
		const min: FeatureVector = {}
		const max: FeatureVector = {}
		for (const f of degreeFeatureSpace.features) {
			const v = fixed[f]
			if (v !== undefined) {
				min[f] = v
				max[f] = v
			} else {
				min[f] = 0
				max[f] = 1
			}
		}
		return { min, max }
	}

	const analyzedRules = $derived(
		localSituationsStatus.loading
			? []
			: map2D(AUTOGENERATED_RULES, r => {
					const analyzed = analyzeRule(r, degreeFeatureSpace.computeFeatureVector, problem)
					return {
						...analyzed,
						recurrenceEquation: buildRecurrenceStrings(
							analyzed.branchDetails.map(b => b.featuresDelta)
						)
					}
				})
	)

	const filteredLocalSituations = $derived(
		localSituationsStatus.loading ? [] : ALL_LOCAL_SITUATIONS.map(x => x.situationId)
	)
	const displaySituations = $derived([...filteredLocalSituations.slice(0, 500)])
	const filteredRules = $derived(
		localSituationsStatus.loading ? [] : filteredLocalSituations.map(s => analyzedRules[s])
	)

	// svelte-ignore state_referenced_locally
	let userWeights = $state(degreeFeatureSpace.createFeatureVector(1))
	let isWeightSearchRunning = $state(false)
	let weightSearchProgress = $state({ mode: "", phase: "", percent: 0 })
	let didAutoStartOptimization = $state(false)

	let hoveredGraph = $state<Graph | null>(null)
	let hoveredSituationId = $state<number | null>(null)
	let showExportJson = $state(false)
	let exportJson = $state<string>("")
	let exportJsonInfo = $state<{ bytes: number; generatedAtMs: number } | null>(null)
	let exportJsonError = $state<string>("")

	let lastBestWeights = $state<FeatureVector | null>(null)
	let lastBestBase = $state<number | null>(null)
	let currentSearchBounds = $state<null | {
		min: FeatureVector
		max: FeatureVector
	}>(null)

	const scalarRecurrences = $derived.by(() => {
		if (localSituationsStatus.loading) return []
		return map2D(analyzedRules, generatedGetRuleSolution)
	})

	type SituationBest =
		| { status: "ok"; base: number }
		| { status: "divergent" }
		| { status: "error" }
		| { status: "none" }

	const bestSituation = $derived.by(() => {
		if (localSituationsStatus.loading) return [] as SituationBest[]
		return analyzedRules.map((rulesForSituation, situationId): SituationBest => {
			if (!rulesForSituation?.length) return { status: "none" }

			let bestBase = Infinity
			let sawDivergent = false
			let sawError = false

			for (const rule of rulesForSituation) {
				const solved = scalarRecurrences[situationId]?.[rule.ruleId]
				if (!solved?.weighted) continue
				if (!solved.weighted.decreasing) {
					sawDivergent = true
					continue
				}

				const solution = solved.solution
				if (solution.ok && !solution.divergent) {
					const roots = Object.values(solution.root)
					if (roots.length === 0) continue
					bestBase = Math.min(bestBase, ...roots)
				} else if (solution.ok) {
					sawDivergent = true
				} else {
					sawError = true
				}
			}

			if (bestBase !== Infinity) return { status: "ok", base: bestBase }
			if (sawError) return { status: "error" }
			if (sawDivergent) return { status: "divergent" }
			return { status: "none" }
		})
	})

	const sortedDisplaySituations = $derived.by(() => {
		const sol = map2D(scalarRecurrences, ({ solution: x }) =>
			x?.ok ? (x.divergent ? Infinity : Object.values(x.root)[0]) : 0
		)
		return displaySituations.toSorted((a, b) => Math.min(...sol[b]) - Math.min(...sol[a])).slice(0,100)
	})

	/**
	 * Manager for the optimization Web Worker.
	 */
	const optimizationManager = new OptimizationManager()

	/**
	 * Starts the weight optimization search using the current filtered rules and bounds.
	 */
	const handleStartSearch = () => {
		if (isWeightSearchRunning || filteredRules.length === 0) return

		isWeightSearchRunning = true
		currentSearchBounds = currentSearchBounds ?? buildDefaultBounds(fixedPartialMeasure)
		lastBestWeights = null
		lastBestBase = null
		weightSearchProgress = { mode: "Optimizing", phase: "Initializing...", percent: 0 }

		const ruleDeltasGroups = map2D(filteredRules, rule =>
			rule.branchDetails.map(b => degreeFeatureSpace.features.map(f => b.featuresDelta[f] ?? 0))
		)
		optimizationManager.start({
			featureKeys: degreeFeatureSpace.features,
			ruleDeltasGroups,
			bounds: currentSearchBounds,
			onProgress: percent => {
				weightSearchProgress.percent = percent
			},
			onPhase: phase => {
				weightSearchProgress.phase = phase
			},
			onBest: (w, value) => {
				if (lastBestBase === null || value < lastBestBase) {
					userWeights = w
					lastBestWeights = w
					lastBestBase = value
				}
			},
			onDone: () => {
				isWeightSearchRunning = false
				weightSearchProgress.phase = ""
			},
			onError: msg => {
				console.error(msg)
				isWeightSearchRunning = false
				weightSearchProgress.phase = ""
			}
		})
	}

	/**
	 * Computes the weighted recurrence and solution for a specific rule.
	 * @param rule - The analyzed branching rule.
	 * @returns An object containing the weighted recurrence and its solution, or null if not found.
	 */
	function generatedGetRuleSolution(rule: BranchingRuleWithAnalysis) {
		const deltas = rule.branchDetails.map(branch => branch.featuresDelta)
		const weighted = buildScalarRecurrence(deltas, userWeights)
		const solution = solveRecurrencesFromStrings(weighted.equation)
		return { weighted, solution }
	}

	function buildExportPayload() {
		if (localSituationsStatus.loading) return [] as Array<unknown>
		return filteredLocalSituations.map(situationId => {
			const situation = ALL_LOCAL_SITUATIONS[situationId]
			const rules = analyzedRules[situationId] ?? []
			return {
				situationId,
				signature: situation?.signature ?? `#${situationId}`,
				rules: rules.map(r => ({
					ruleId: r.ruleId,
					// Per-branch delta in the tracked feature vector.
					branchDeltas: r.branchDetails.map(b => b.featuresDelta)
				}))
			}
		})
	}

	function ensureExportJsonGenerated() {
		if (localSituationsStatus.loading) return
		try {
			exportJsonError = ""
			const payload = buildExportPayload()
			exportJson = JSON.stringify(payload, null, 2)
			exportJsonInfo = {
				bytes: new TextEncoder().encode(exportJson).length,
				generatedAtMs: Date.now()
			}
		} catch (err) {
			exportJsonError = err instanceof Error ? err.message : String(err)
		}
	}

	async function handleCopyExportJson() {
		if (!browser) return
		ensureExportJsonGenerated()
		if (!exportJson || exportJsonError) return
		try {
			await navigator.clipboard.writeText(exportJson)
		} catch {
			// Fallback: select + copy via a temporary textarea.
			const ta = document.createElement("textarea")
			ta.value = exportJson
			ta.style.position = "fixed"
			ta.style.top = "-1000px"
			ta.style.left = "-1000px"
			document.body.appendChild(ta)
			ta.focus()
			ta.select()
			document.execCommand("copy")
			document.body.removeChild(ta)
		}
	}

	onDestroy(() => {
		optimizationManager.stop()
	})

	$effect(() => {
		void maxDegree
		void depth
		if (browser) queueMicrotask(computeSituations)
		else computeSituations()
	})

	$effect(() => {
		// Reset UI/optimizer state when the feature set changes.
		degreeFeatureSpace.features.join("|")
		optimizationManager.stop()
		isWeightSearchRunning = false
		lastBestWeights = null
		lastBestBase = null
		weightSearchProgress = { mode: "", phase: "", percent: 0 }
		currentSearchBounds = null
		userWeights = degreeFeatureSpace.createFeatureVector(1)
	})

	$effect(() => {
		// Auto-start the first optimization once per page load.
		if (didAutoStartOptimization) return
		if (!browser) return
		if (localSituationsStatus.loading) return
		if (filteredRules.length === 0) return
		if (isWeightSearchRunning) return
		didAutoStartOptimization = true
		queueMicrotask(handleStartSearch)
	})
</script>

<div class="mx-auto max-w-7xl space-y-6 px-4 py-6 text-sm text-gray-800 sm:px-6">
	<header class="space-y-2">
		<h1 class="text-2xl font-semibold tracking-tight text-gray-900">
			Branching Rules for Weighted Independent Set
		</h1>
		<p class="max-w-3xl text-sm leading-relaxed text-gray-600">
			We encode membership with colors &#123;0,1&#125;: color 1 means “in”, color 0 means “out”.
			Branching assigns the root to 0 or 1 and propagates constraints. We always branch on the
			vertex of highest chain-degree.
		</p>
	</header>

	<div class="grid gap-6 lg:grid-cols-[360px_1fr]">
		<!-- Sidebar -->
		<aside class="space-y-4 lg:sticky lg:top-6 lg:self-start">
			<section class="rounded-xl border border-gray-200 bg-white p-4 shadow-sm">
				<div class="flex items-center justify-between">
					<div class="text-xs font-semibold tracking-wide text-gray-600 uppercase">Controls</div>
				</div>
				<div class="mt-4 space-y-4">
					<label class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600">
						<span class="uppercase">Depth</span>
						<input
							type="number"
							min="1"
							step="1"
							class="rounded-md border border-gray-300 bg-white px-3 py-2 text-sm text-gray-800 focus:border-sky-500 focus:outline-none"
							bind:value={depthInput} />
						<p class="text-[11px] font-normal text-gray-500">
							How many neighborhood layers are included in the local situation.
						</p>
					</label>

					<label class="flex flex-col gap-1 text-xs font-semibold tracking-wide text-gray-600">
						<span
							><span class="uppercase">Degree bucket threshold</span>
							<span class="font-mono">d</span></span>
						<input
							type="number"
							min="3"
							step="1"
							class="rounded-md border border-gray-300 bg-white px-3 py-2 text-sm text-gray-800 focus:border-sky-500 focus:outline-none"
							bind:value={maxDegreeInput} />
						<p class="text-[11px] font-normal text-gray-500">
							Changes the set of atomic types and re-enumerates local situations.
						</p>
					</label>

					<div class="rounded-lg border border-gray-200 bg-gray-50 px-3 py-2">
						<div class="flex items-start gap-2">
							<span
								class={localSituationsStatus.loading
									? "mt-0.5 inline-flex h-3.5 w-3.5 animate-spin rounded-full border-2 border-sky-400 border-t-transparent"
									: "mt-0.5 inline-flex h-3.5 w-3.5 rounded-full bg-emerald-500"}
								aria-hidden="true"></span>
							<div class="min-w-0">
								<div class="text-xs font-semibold text-gray-700">Local situations</div>
								<div class="text-[11px] text-gray-600">
									{#if localSituationsStatus.loading}
										Computed {localSituationsStatus.computed} so far…
									{:else}
										Found {localSituationsStatus.success} in {formatMillis(
											localSituationsStatus.elapsedMs
										)}
									{/if}
								</div>
							</div>
						</div>
					</div>

					<div class="flex items-start justify-between gap-3">
						<div class="min-w-0">
							<div class="text-xs font-semibold text-gray-700">Optimization</div>
							<div class="mt-0.5 text-[11px] text-gray-600">
								{#if isWeightSearchRunning}
									<span class="font-medium text-amber-700">{weightSearchProgress.phase}</span>
									<span class="text-gray-500">
										— {formatPercent(weightSearchProgress.percent * 100)}</span>
								{:else if filteredRules.length === 0}
									Waiting for situations…
								{:else if lastBestWeights}
									Completed latest optimization.
								{:else}
									Not started.
								{/if}
							</div>
						</div>
						<button
							class="shrink-0 rounded-md bg-amber-600 px-3 py-2 text-[11px] font-semibold text-white uppercase shadow-sm hover:bg-amber-700 disabled:cursor-not-allowed disabled:bg-amber-300"
							onclick={handleStartSearch}
							disabled={isWeightSearchRunning ||
								filteredRules.length === 0 ||
								localSituationsStatus.loading}>
							Start
						</button>
					</div>
					<p class="text-[11px] leading-relaxed text-gray-500">
						Heuristically find a measure minimizing the base b in O(b<sup>μ</sup>) that upper bounds
						all recurrences.
					</p>

					{#if lastBestWeights && lastBestBase !== null}
						<div
							class="rounded-lg border border-amber-200 bg-amber-50 px-3 py-2 text-[11px] text-amber-900">
							<div class="font-semibold">Best so far</div>
							<div class="mt-1 space-y-1">
								<div>
									<span class="text-amber-900">Measure:</span>
									<span class="ml-1 font-mono text-amber-800">
										<BasicSubscripts raw={`μ = ${formatMeasure(lastBestWeights)}`} />
									</span>
								</div>
								<div>Base: O({formatNumber(lastBestBase)}<sup>μ</sup>)</div>
							</div>
						</div>
					{/if}
				</div>
			</section>

			{#if Object.keys(fixedPartialMeasure).length > 0}
				<section
					class="rounded-xl border border-indigo-200 bg-indigo-50/50 p-4 text-[11px] text-gray-700">
					<div class="font-semibold text-indigo-900">Fixed coefficients</div>
					<ul class="mt-2 space-y-1">
						{#each Object.entries(fixedPartialMeasure) as [feature, value] (feature)}
							<li class="flex items-center gap-2 font-mono">
								<BasicSubscripts raw={"coefficient." + feature} />
								<span class="text-gray-500">=</span>
								<span class="text-gray-800">{value}</span>
							</li>
						{/each}
					</ul>
				</section>
			{/if}

			<details class="group rounded-xl border border-emerald-200 bg-white p-4 shadow-sm">
				<summary
					class="cursor-pointer list-none text-xs font-semibold tracking-wide text-emerald-700 uppercase select-none">
					<div class="flex items-center justify-between">
						<span>Custom Measure</span>
						<span class="text-emerald-300 group-open:rotate-90">›</span>
					</div>
				</summary>
				<p class="mt-2 text-[11px] leading-relaxed text-gray-600">
					Set coefficients to define the scalar measure <span class="font-mono">μ</span> used for every
					rule.
				</p>
				<div class="mt-3 grid gap-3 sm:grid-cols-2">
					{#each degreeFeatureSpace.features as f (f)}
						<label
							class="flex flex-col gap-1 text-[11px] font-semibold tracking-wide text-gray-600">
							<span><span class="uppercase">Coeff</span> <BasicSubscripts raw={f} /></span>
							<input
								type="number"
								min="0"
								step="0.1"
								class="rounded-md border border-gray-300 px-3 py-2 text-sm text-gray-800 focus:border-emerald-500 focus:outline-none"
								bind:value={userWeights[f]} />
						</label>
					{/each}
				</div>
				<p class="mt-3 text-[11px] text-gray-500">
					Current measure:
					<span class="ml-1 font-mono text-gray-800"
						>μ = <BasicSubscripts raw={formatMeasure(userWeights)} /></span>
				</p>
				{#if isWeightSearchRunning}
					<div class="mt-2 flex items-center gap-2 text-[11px] font-semibold text-emerald-700">
						<span
							class="inline-flex h-4 w-4 animate-spin rounded-full border-2 border-emerald-400 border-t-transparent"
							aria-hidden="true"></span>
						<span>Searching optimal weights…</span>
					</div>
				{/if}
			</details>

			<details class="group rounded-xl border border-gray-200 bg-white p-4 shadow-sm">
				<summary
					class="cursor-pointer list-none text-xs font-semibold tracking-wide text-gray-600 uppercase select-none">
					<div class="flex items-center justify-between">
						<span>Legend</span>
						<span class="text-gray-400 group-open:rotate-90">›</span>
					</div>
				</summary>
				<div class="mt-3">
					<ul class="grid gap-x-4 gap-y-2 sm:grid-cols-1">
						{#each degreeFeatureSpace.features as f (f)}
							<li class="text-[11px] text-gray-700">
								<span class="font-mono text-gray-900"><BasicSubscripts raw={f} /></span>
								<span class="text-gray-500"> — {degreeFeatureSpace.describeFeature(f)}</span>
							</li>
						{/each}
					</ul>
				</div>
			</details>
		</aside>

		<!-- Main -->
		<main class="space-y-4">
			<section class="rounded-xl border border-gray-200 bg-white p-5 shadow-sm">
				<div class="flex flex-wrap items-start justify-between gap-3">
					<div class="min-w-0">
						<div class="text-xs font-semibold tracking-wide text-gray-600 uppercase">
							Export JSON
						</div>
						<p class="mt-1 text-[11px] leading-relaxed text-gray-600">
							Copies a JSON list of all canonical situations currently generated, including each
							situation’s signature and the per-branch feature deltas of every autogenerated rule.
						</p>
						{#if exportJsonInfo}
							<div class="mt-1 text-[11px] text-gray-500">
								Generated {formatNumber(exportJsonInfo.bytes)} bytes.
							</div>
						{/if}
						{#if exportJsonError}
							<div class="mt-2 text-[11px] text-red-600">Export error: {exportJsonError}</div>
						{/if}
					</div>
					<div class="flex shrink-0 items-center gap-2">
						<button
							class="rounded-md border border-gray-300 bg-white px-3 py-2 text-[11px] font-semibold text-gray-700 shadow-sm hover:bg-gray-50 disabled:cursor-not-allowed disabled:opacity-60"
							onclick={() => {
								ensureExportJsonGenerated()
								showExportJson = !showExportJson
							}}
							disabled={localSituationsStatus.loading}>
							{showExportJson ? "Hide" : "Show"}
						</button>
						<button
							class="rounded-md bg-sky-600 px-3 py-2 text-[11px] font-semibold text-white uppercase shadow-sm hover:bg-sky-700 disabled:cursor-not-allowed disabled:bg-sky-300"
							onclick={handleCopyExportJson}
							disabled={localSituationsStatus.loading}>
							Copy
						</button>
					</div>
				</div>
				{#if localSituationsStatus.loading}
					<div class="mt-3 text-[11px] text-gray-500">
						Waiting for situations to finish generating…
					</div>
				{:else if showExportJson}
					<div class="mt-4">
						<textarea
							class="h-40 w-full resize-y rounded-md border border-gray-200 bg-gray-50 p-3 font-mono text-[11px] text-gray-800"
							readonly
							value={exportJson}></textarea>
						<div class="mt-2 text-[11px] text-gray-500">
							Schema:
							<span class="ml-1 font-mono"
								>[&#123;situationId, signature, rules: [&#123;ruleId, branchDeltas:
								FeatureVector[]&#125;]&#125;]</span>
						</div>
					</div>
				{/if}
			</section>

			<section class="rounded-xl border border-gray-200 bg-white p-5 shadow-sm">
				<header class="space-y-1">
					<h2 class="text-lg font-semibold text-gray-900">Canonical situations</h2>
					<p class="text-sm text-gray-600">
						Generated {filteredLocalSituations.length} situations defined by their
						<em>round-1 type</em>
						<span
							><i>t</i><sup>1</sup>(<i>v</i>) = (<span>atp</span>(<i>v</i>); &lbrace;&lbrace;
							<span>atp</span>(<i>u</i>) : <i>u</i> &isin;
							<i>N</i>(<i>v</i>) &rbrace;&rbrace;)</span>
						and <span><i>t</i><sup>2</sup>(<i>v</i>)</span>, sorted from worst to best branching
						factor for μ.
					</p>
				</header>

				<div class="mt-5 grid gap-4">
					{#await sortedDisplaySituations}
						<div class="text-sm text-gray-500">Preparing display…</div>
					{:then x}
						{#each x as s (ALL_LOCAL_SITUATIONS[s].signature)}
							{@const rulesForSituation = analyzedRules[s] ?? []}
							{@const best = bestSituation[s]}
							<div class="rounded-lg border border-gray-200 bg-gray-50 p-4">
								<div class="flex items-start justify-between gap-3">
									<div class="min-w-0">
										<div class="text-xs font-semibold tracking-wide text-gray-700 uppercase">
											Situation #{s}
										</div>
										<div class="mt-0.5 font-mono text-[11px] text-gray-500">
											{ALL_LOCAL_SITUATIONS[s].signature}
										</div>
									</div>
									<div class="text-gray-500">
										{#if best?.status === "ok"}
											O({formatNumber(best.base)}<sup>μ</sup>)
										{:else if best?.status === "divergent"}
											Divergent
										{:else if best?.status === "error"}
											Solver error
										{:else}
											No solution
										{/if}
									</div>
								</div>

								<div
									class="mt-3 w-fit rounded-md border border-dashed border-gray-200 bg-white p-2">
									<GraphView
										graph={hoveredSituationId === s && hoveredGraph
											? hoveredGraph
											: ALL_LOCAL_SITUATIONS[s].canon}
										scale={0.6} />
								</div>

								{#if rulesForSituation.length === 0}
									<p class="mt-3 text-xs text-gray-500">No rules available for this situation.</p>
								{:else}
									<div class="mt-3 space-y-2">
										{#each rulesForSituation as rule (rule.ruleId)}
											{@const solved = scalarRecurrences[rule.situationId][rule.ruleId]}
											<details class="group rounded-md border border-gray-200 bg-white">
												<summary
													class="cursor-pointer list-none px-3 py-2 text-xs font-semibold text-gray-800 select-none">
													<div class="flex items-center justify-between gap-3">
														<div class="flex items-center gap-2">
															<span
																class="rounded bg-gray-100 px-2 py-0.5 font-mono text-[11px] text-gray-700">
																Rule {rule.ruleId}
															</span>
															<span class="text-[11px] font-normal text-gray-500">
																{rule.branches.length} branch{rule.branches.length === 1
																	? ""
																	: "es"}
															</span>
														</div>
														<span class="text-gray-400 group-open:rotate-90">›</span>
													</div>
												</summary>
												<div class="space-y-3 px-3 pb-3 text-sm text-gray-800">
													<div class="rounded-md bg-gray-50 px-3 py-2 text-[11px] text-gray-700">
														<div class="font-semibold text-gray-700">Branches</div>
														<div class="mt-2 space-y-1">
															{#each rule.branches as branch, idx (branch.assignments)}
																{@const details = rule.branchDetails[idx]}
																<!-- svelte-ignore a11y_no_static_element_interactions -->
																<div
																	class="flex flex-wrap items-baseline gap-2 rounded px-1 py-0.5 hover:bg-white"
																	onmouseenter={() => {
																		hoveredGraph = details.after
																		hoveredSituationId = rule.situationId
																	}}
																	onmouseleave={() => {
																		hoveredGraph = null
																		hoveredSituationId = null
																	}}>
																	<div class="font-mono text-[11px] text-gray-900">
																		{describeAssignments(branch.assignments)}
																	</div>
																	<div class="text-gray-300">|</div>
																	<div class="font-mono text-[11px] text-gray-700">
																		<BasicSubscripts
																			raw={buildRecurrenceStrings([details.featuresDelta], true)} />
																	</div>
																</div>
															{/each}
														</div>
													</div>
													{#if solved?.weighted}
														<div class="rounded-md border border-gray-200 bg-white px-3 py-2">
															<div class="text-[11px] font-semibold text-gray-700">Recurrence</div>
															<div class="mt-1 font-mono text-[11px] text-gray-800">
																{solved.weighted.equation}
															</div>
															<div class="mt-2 text-[11px] text-gray-700">
																<span class="font-semibold">Solution:</span>
																<span class="ml-1">
																	{#if solved.weighted.decreasing}
																		{#await solved.solution}
																			<span class="text-gray-500">Computing…</span>
																		{:then solution}
																			{#if solution?.ok && !solution?.divergent}
																				{formatAsymptotics(solution.root)}
																			{:else if solution?.ok}
																				Divergent
																			{:else}
																				<span class="text-red-600"
																					>Solver error: {solution?.error ?? "unknown"}</span>
																			{/if}
																		{:catch error}
																			<span class="text-red-600">
																				Unknown error: {error instanceof Error
																					? error.message
																					: String(error)}
																			</span>
																		{/await}
																	{:else}
																		Divergent
																	{/if}
																</span>
															</div>
														</div>
													{/if}
												</div>
											</details>
										{/each}
									</div>
								{/if}
							</div>
						{/each}
					{/await}
				</div>
			</section>
		</main>
	</div>
</div>
